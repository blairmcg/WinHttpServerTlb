#include <winapifamily.h>
#include <sdkddkver.h>
#include "CustomAttribs.h"

typedef [public, helpstring("The properties supported by the server side HTTP API."), v1_enum] enum _HTTP_SERVER_PROPERTY
{
	[helpstring("Used for enabling server side authentication.")]
	HttpServerAuthenticationProperty = 0,

	[helpstring("Used for enabling logging.")]
	HttpServerLoggingProperty = 1,

	[helpstring("Used for setting QoS properties.")]
	HttpServerQosProperty = 2,

	[helpstring("Used for configuring timeouts.")]
	HttpServerTimeoutsProperty = 3,

	[helpstring("Used for limiting request queue lengths.")]
	HttpServerQueueLengthProperty = 4,

	[helpstring("Used for manipulating the state.")]
	HttpServerStateProperty = 5,

	[helpstring("Used for modifying the verbosity level of 503 type responses generated by server side API.")]
	HttpServer503VerbosityProperty = 6,

	[helpstring("Used for manipulating Url Group to Request Queue association.")]
	HttpServerBindingProperty = 7,

	[helpstring("Extended authentication property.")]
	HttpServerExtendedAuthenticationProperty = 8,

	[helpstring("Listening endpoint property.")]
	HttpServerListenEndpointProperty = 9,

	[helpstring("Authentication channel binding property")]
	HttpServerChannelBindProperty = 10,

	[helpstring("IP Protection level policy for a Url Group.")]
	HttpServerProtectionLevelProperty = 11

} HTTP_SERVER_PROPERTY, *PHTTP_SERVER_PROPERTY;

typedef
[
	helpstring("Generic property flags. Each structure defining a property info typically contain an element of this type."),
	uuid(6BA76C16-B60F-4235-9179-145A93B3F5CB)
]
struct HTTP_PROPERTY_FLAGS
{
	[nonbrowsable] BOOL Present /*: 1*/;

} HTTP_PROPERTY_FLAGS;
typedef HTTP_PROPERTY_FLAGS *PHTTP_PROPERTY_FLAGS;

typedef
[public, v1_enum]
[helpstring("Enabled state")]
enum _HTTP_ENABLED_STATE
{
	HttpEnabledStateActive,
	HttpEnabledStateInactive,

} HTTP_ENABLED_STATE, *PHTTP_ENABLED_STATE;

typedef
[
	uuid(5DC84435-3EB8-42FE-94BF-25F253E612FD),
	helpstring("The HTTP_STATE_INFO structure is used to enable or disable a Server Session or URL Group.")
]
struct HTTP_STATE_INFO
{
	[nonbrowsable, helpstring("specifying whether the property is present.")] 
	HTTP_PROPERTY_FLAGS;
	[helpstring("A member of the HTTP_ENABLED_STATE enumeration specifying the whether the configuration object is enabled or disabled.	This can be used to disable a URL Group or Server Session.")]
	HTTP_ENABLED_STATE  State;

} HTTP_STATE_INFO;
typedef [public] HTTP_STATE_INFO *PHTTP_STATE_INFO;


typedef
[
	public,
	v1_enum,
	helpstring("Defines the verbosity level for a request queue which will be used when sending '503 - Service Unavailable' type error responses. Note that this setting only affects the error responses generated internally by HTTPAPI.")
]
enum _HTTP_503_RESPONSE_VERBOSITY
{
	[helpstring("Instead of sending a 503 response, the connection will be reset. This is the default behavior.")]
Http503ResponseVerbosityBasic,

[helpstring("Will send a 503 w/ a generic reason phrase.")]
Http503ResponseVerbosityLimited,

[helpstring("Will send a 503 w/ a detailed reason phrase.")]
Http503ResponseVerbosityFull

} HTTP_503_RESPONSE_VERBOSITY, *PHTTP_503_RESPONSE_VERBOSITY;

typedef
[public, v1_enum]
[helpstring("Network QoS related.")]
enum _HTTP_QOS_SETTING_TYPE
{
	HttpQosSettingTypeBandwidth,
	HttpQosSettingTypeConnectionLimit,
	HttpQosSettingTypeFlowRate

} HTTP_QOS_SETTING_TYPE, *PHTTP_QOS_SETTING_TYPE;

typedef
[
	helpstring("Contains information about a QOS setting."),
	uuid(A0BCEFE3-D299-4E8A-9C7A-6E753A441AD6)
]
struct HTTP_QOS_SETTING_INFO
{
	HTTP_QOS_SETTING_TYPE QosType;
	PVOID QosSetting;
} HTTP_QOS_SETTING_INFO;

typedef [public] HTTP_QOS_SETTING_INFO *PHTTP_QOS_SETTING_INFO;

typedef
[
	helpstring("Used to set or query the limit on the maximum number of outstanding connections for a URL Group."),
	uuid(6FCA5840-1E00-4065-AD55-203BD079A117)
]
struct HTTP_CONNECTION_LIMIT_INFO
{
	[nonbrowsable] HTTP_PROPERTY_FLAGS;
	ULONG MaxConnections;

} HTTP_CONNECTION_LIMIT_INFO;

typedef [public] HTTP_CONNECTION_LIMIT_INFO *PHTTP_CONNECTION_LIMIT_INFO;

typedef
[
	helpstring("Used to set or query the bandwidth throttling limit.This structure must be used when setting or querying the HttpServerBandwidthProperty on a URL Group or server session."),
	uuid(197B6874-68BB-4A22-B2FA-9E02210F4CD9)
]
struct HTTP_BANDWIDTH_LIMIT_INFO
{
	[nonbrowsable, helpstring("Specifies whether the MaxBandwidth property is present.")]
	HTTP_PROPERTY_FLAGS;
	[helpstring("The maximum allowed bandwidth rate in bytesper second. Setting the value to HTTP_LIMIT_INFINITE allows unlimited bandwidth rate. The value cannot be smaller than HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE.")]
	ULONG MaxBandwidth;

} HTTP_BANDWIDTH_LIMIT_INFO;

typedef HTTP_BANDWIDTH_LIMIT_INFO *PHTTP_BANDWIDTH_LIMIT_INFO;

typedef
[
	helpstring("The transfer rate of a response."),
	uuid(C2FAD8F6-F179-4BBB-A5F2-073C416F6704)
]
struct HTTP_FLOWRATE_INFO
{
	[nonbrowsable, helpstring("Specifies whether the property is present.")] HTTP_PROPERTY_FLAGS;
	[helpstring("The maximum bandwidth represented in bytes/second. This is the maximum bandwidth for the response after the burst content, whose size is specified in BurstSize, has been sent.")]
	ULONG MaxBandwidth;
	[helpstring("The peak bandwidth represented in bytes/second. This is the maximum bandwidth at which the burst is delivered.")]
	ULONG MaxPeakBandwidth;
	[helpstring("The size of the content, in bytes, to be delivered at MaxPeakBandwidth. Once this content has been delivered, the response is throttled at MaxBandwidth.")]
	ULONG BurstSize;

} HTTP_FLOWRATE_INFO;

typedef HTTP_FLOWRATE_INFO *PHTTP_FLOWRATE_INFO;

typedef
[public, v1_enum]
[helpstring("For manipulating global timeout settings. These timers run when connection does not belong to any application. Value zero is not allowed for driver wide timeout settings.")]
enum _HTTP_SERVICE_CONFIG_TIMEOUT_KEY
{
	IdleConnectionTimeout = 0,
	HeaderWaitTimeout

} HTTP_SERVICE_CONFIG_TIMEOUT_KEY, *PHTTP_SERVICE_CONFIG_TIMEOUT_KEY;

typedef USHORT HTTP_SERVICE_CONFIG_TIMEOUT_PARAM, *PHTTP_SERVICE_CONFIG_TIMEOUT_PARAM;

typedef
[
	helpstring("To set a timeout value use the set structure. To query/delete use the key directly. When you query a timeout value the output buffer must be exactly the sizeof param."),
	uuid(6F4ABCFC-2A59-4996-A958-5DE93DC64213)
]
struct HTTP_SERVICE_CONFIG_TIMEOUT_SET
{
	HTTP_SERVICE_CONFIG_TIMEOUT_KEY KeyDesc;
	HTTP_SERVICE_CONFIG_TIMEOUT_PARAM ParamDesc;

} HTTP_SERVICE_CONFIG_TIMEOUT_SET;

typedef [public] HTTP_SERVICE_CONFIG_TIMEOUT_SET *PHTTP_SERVICE_CONFIG_TIMEOUT_SET;

typedef
[
	helpstring("For manipulating application specific timeout settings. These timers run when there's a request being processed on a connection and HTTPAPI has already associated the request with an application."),
	uuid(7DAE0007-41D0-4925-B425-A14D837D56D0)
]
struct HTTP_TIMEOUT_LIMIT_INFO
{
	[helpstring("Flags specifying which properties are present.")]
	HTTP_PROPERTY_FLAGS;

	[helpstring("The time, in seconds, allowed for the request entity body to arrive.")]
	USHORT EntityBody;
	[helpstring("The time, in seconds, allowed for the HTTP Server API to drain the entity body on a Keep-Alive connection.")]
	USHORT DrainEntityBody;
	[helpstring("The time, in seconds, allowed for the request to remain in the request queue before the application picks it up.")]
	USHORT RequestQueue;

	[helpstring("The time, in seconds, allowed for an idle connection.")]
	USHORT IdleConnection;
	[helpstring("The time, in seconds, allowed for the HTTP Server API to parse the request header.")]
	USHORT HeaderWait;

	[helpstring("The minimum send rate, in bytes-per-second, for the response. The default response send rate is 150 bytes-per-second.")]
	ULONG MinSendRate;

} HTTP_TIMEOUT_LIMIT_INFO;

typedef [public] HTTP_TIMEOUT_LIMIT_INFO *PHTTP_TIMEOUT_LIMIT_INFO;

typedef
[
	helpstring("Controls whether IP-based URLs should listen on the specific IP or wildcard."),
	uuid(C96F66FD-B678-4046-9100-ED4B4BC7C9FE)
]
struct HTTP_LISTEN_ENDPOINT_INFO
{
	HTTP_PROPERTY_FLAGS;

	BOOLEAN EnableSharing;

} HTTP_LISTEN_ENDPOINT_INFO;

typedef [public] HTTP_LISTEN_ENDPOINT_INFO *PHTTP_LISTEN_ENDPOINT_INFO;


typedef
[
	uuid(EED513F2-C404-408C-9DDB-F5D39020D426)
]
struct HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS
{
	USHORT              DomainNameLength;
	PWSTR               DomainName;
	USHORT              RealmLength;
	PWSTR               Realm;
} HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS;

typedef [public] HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS *PHTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS;

typedef
[
	uuid(813FF062-E4ED-4B4C-8EEF-9D94A1FB65C4)
]
struct HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS
{
	USHORT      RealmLength;
	PWSTR       Realm;
} HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS;

typedef [public] HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS *PHTTP_SERVER_AUTHENTICATION_BASIC_PARAMS;


typedef
[
	uuid(7F4599B6-BDFD-4A19-8A4A-A7FD55A9E207)
]
struct HTTP_SERVER_AUTHENTICATION_INFO
{
	HTTP_PROPERTY_FLAGS;

	ULONG AuthSchemes;

	BOOLEAN ReceiveMutualAuth;
	BOOLEAN ReceiveContextHandle;
	BOOLEAN DisableNTLMCredentialCaching;

	UCHAR   ExFlags;

	HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS DigestParams;
	HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS  BasicParams;

} HTTP_SERVER_AUTHENTICATION_INFO;

typedef [public] HTTP_SERVER_AUTHENTICATION_INFO *PHTTP_SERVER_AUTHENTICATION_INFO;

typedef
[
	public, v1_enum,
	helpstring("Specifies the string type for service names.")
]
enum _HTTP_SERVICE_BINDING_TYPE
{
	HttpServiceBindingTypeNone = 0,
	HttpServiceBindingTypeW,
	HttpServiceBindingTypeA

} HTTP_SERVICE_BINDING_TYPE;

typedef
[
	helpstring("Common base for the HTTP_SERVICE_BINDING_A structure and the HTTP_SERVICE_BINDING_W structure."),
	uuid(80F84F87-9667-42D4-ACE4-1004DFE14475)
]
struct HTTP_SERVICE_BINDING_BASE
{
	[helpstring("Indicates whether the data is in ASCII or Unicode.")]
	HTTP_SERVICE_BINDING_TYPE Type;

} HTTP_SERVICE_BINDING_BASE;

typedef HTTP_SERVICE_BINDING_BASE *PHTTP_SERVICE_BINDING_BASE;

typedef
[
	helpstring("Provides Service Principle Name (SPN) in ASCII."),
	uuid(88CA7833-A66A-4E2F-98BC-CD2313254B15)
]
struct HTTP_SERVICE_BINDING_A
{
	HTTP_SERVICE_BINDING_BASE;
	[helpstring("A pointer to a buffer that represents the SPN.")]
	_Counted_String_Ptr_(BufferSize) PCHAR Buffer;
	[nonbrowsable, helpstring("The length, in bytes, of the string in Buffer.")]
	ULONG BufferSize;

} HTTP_SERVICE_BINDING_A;

typedef HTTP_SERVICE_BINDING_A *PHTTP_SERVICE_BINDING_A;

typedef
[
	helpstring("Provides Service Principle Name (SPN) in Unicode."),
	uuid(9CD42842-29B3-4E02-B9DC-306B51F0166D)
]
struct HTTP_SERVICE_BINDING_W
{
	HTTP_SERVICE_BINDING_BASE;
	[helpstring("A pointer to a buffer that represents the SPN.")]
	_Counted_String_Ptr_(BufferSize) PWCHAR Buffer;
	[nonbrowsable, helpstring("The length, in bytes, of the string in Buffer.")]
	ULONG BufferSize;

} HTTP_SERVICE_BINDING_W;

typedef HTTP_SERVICE_BINDING_W *PHTTP_SERVICE_BINDING_W;

typedef [v1_enum] enum _HTTP_AUTHENTICATION_HARDENING_LEVELS
{
	HttpAuthenticationHardeningLegacy = 0,
	HttpAuthenticationHardeningMedium,
	HttpAuthenticationHardeningStrict

} HTTP_AUTHENTICATION_HARDENING_LEVELS;

typedef
[
	uuid(84EA1900-0BC6-4AC8-9025-7F74436D5DC9),
	helpstring("The HTTP_CHANNEL_BIND_INFO structure is used to set or query channel bind authentication.")
]
struct HTTP_CHANNEL_BIND_INFO
{
	[helpstring(" HTTP_AUTHENTICATION_HARDENING_LEVELS value indicating the hardening level levels to be set or queried per server session or URL group.")]
	HTTP_AUTHENTICATION_HARDENING_LEVELS Hardening;
	[helpstring("Flags from the HTTP_CHANNEL_BIND_* enumeration that determine the behaviour of authentication.")]
	ULONG Flags;
	[helpstring("Pointer to a buffer holding an array of 1 or more service names. Each service name is represented by either an HTTP_SERVICE_BINDING_A structure or an HTTP_SERVICE_BINDING_W structure, dependent upon whether the name is ASCII or Unicode.")]
	_Counted_Array_Ptr_(NumberOfServiceNames) PHTTP_SERVICE_BINDING_BASE ServiceNames;
	[nonbrowsable, helpstring("The number of names in ServiceNames.")]
	ULONG NumberOfServiceNames;

} HTTP_CHANNEL_BIND_INFO;

typedef HTTP_CHANNEL_BIND_INFO *PHTTP_CHANNEL_BIND_INFO;

typedef
[
	uuid(2FC21C2A-E0C8-4C4C-A68F-E8270F8FBD2A)
]
struct HTTP_REQUEST_CHANNEL_BIND_STATUS
{
	[helpstring("The service name from the client. This is populated if the request's Channel Binding Token (CBT) is not configured to retrieve service names.")]
	PHTTP_SERVICE_BINDING_BASE ServiceName;
	[helpstring("A pointer to a buffer that contains the secure channel endpoint binding.")]
	_Counted_Array_Ptr_(ChannelTokenSize) PUCHAR ChannelToken;
	[nonbrowsable, helpstring("The length of the ChannelToken buffer in bytes.")]
	ULONG ChannelTokenSize;
	_Reserved_
	ULONG Flags;

} HTTP_REQUEST_CHANNEL_BIND_STATUS;
typedef HTTP_REQUEST_CHANNEL_BIND_STATUS *PHTTP_REQUEST_CHANNEL_BIND_STATUS;


typedef
[
	uuid(9A86EB3D-22EE-4CC3-980D-F3427EECDB0C)
]
struct HTTP_REQUEST_TOKEN_BINDING_INFO
{
	PUCHAR TokenBinding;
	ULONG TokenBindingSize;

	PUCHAR TlsUnique;
	ULONG TlsUniqueSize;

	PWSTR KeyType;

} HTTP_REQUEST_TOKEN_BINDING_INFO;

typedef [public] HTTP_REQUEST_TOKEN_BINDING_INFO *PHTTP_REQUEST_TOKEN_BINDING_INFO;


typedef
[
	public, v1_enum,
	helpstring("Defines the logging type.")
]
enum _HTTP_LOGGING_TYPE
{
	HttpLoggingTypeW3C,
	HttpLoggingTypeIIS,
	HttpLoggingTypeNCSA,
	HttpLoggingTypeRaw

} HTTP_LOGGING_TYPE, *PHTTP_LOGGING_TYPE;

typedef
[
	public, v1_enum,
	helpstring("Defines the rollover type for log files.")
]
enum _HTTP_LOGGING_ROLLOVER_TYPE
{
	HttpLoggingRolloverSize,
	HttpLoggingRolloverDaily,
	HttpLoggingRolloverWeekly,
	HttpLoggingRolloverMonthly,
	HttpLoggingRolloverHourly

} HTTP_LOGGING_ROLLOVER_TYPE, *PHTTP_LOGGING_ROLLOVER_TYPE;

typedef
[
	helpstring("Configuration structure used for setting the logging property."),
	uuid(41C67887-C529-4196-9C0F-5BB698324D32)
]
struct HTTP_LOGGING_INFO
{
	[helpstring("Specifies whether this property exists or not.")]
	HTTP_PROPERTY_FLAGS;

	[helpstring("Optional logging flags.")]
	ULONG LoggingFlags;

	[helpstring("Optional informational software directive string for W3C type logging. Not used for other types of logging. If nothing is provided here HTTPAPI will log a default string. Any arbitrary string could be used here to identify the application.")]
	PCWSTR SoftwareName;
	[helpstring("Length of SoftwareName in number of bytes. Cannot be greater than MAX_PATH.")]
	USHORT SoftwareNameLength;

	[helpstring("Length of DirectoryName in number of bytes. Cannot be greater than MAX_PATH.")]
	USHORT DirectoryNameLength;
	[helpstring("Log file directory must be a fully qualified path.")]
	PCWSTR DirectoryName;

	[helpstring("Specifies the format for the log files.")]
	HTTP_LOGGING_TYPE Format;

	[helpstring("Bitmask value indicates which fields to be logged if the log format is set to W3C.This must be the 'bitwise or' of the HTTP_LOG_FIELD_... values.")]
	ULONG Fields;

	_Reserved_
	PVOID pExtFields;
	_Reserved_
	USHORT NumOfExtFields;

	_Reserved_
	USHORT MaxRecordSize;

	[helpstring("Defines the rollover type for the log files.")]
	HTTP_LOGGING_ROLLOVER_TYPE RolloverType;

	[helpstring("Indicates the maximum size (in bytes) after which the log files should be rolled over.A value of HTTP_LIMIT_INFINITE (-1) indicates an unlimited size. This value is discarded if rollover type is not set to HttpLoggingRolloverSize.")]
	ULONG RolloverSize;

	[helpstring("Specifies the security descriptor to be applied to the log files and the sub - directories. If null we will inherit the system default. This security descriptor must be self-relative.")]
	PSECURITY_DESCRIPTOR pSecurityDescriptor;

} HTTP_LOGGING_INFO;

typedef HTTP_LOGGING_INFO *PHTTP_LOGGING_INFO;

typedef
[
	helpstring("The HTTP_BINDING_INFO structure is used to associate a URL Group with a request queue. This structure must be used when setting or querying the HttpServerBindingProperty on a URL Group."),
	uuid(B253697C-F239-4FB6-B474-B35DB2C4848F)
]
struct HTTP_BINDING_INFO
{
	[nonbrowsable, helpstring("Specifies whether the RequestQueueHandle property is present.")]
	HTTP_PROPERTY_FLAGS;
	[helpstring("The request queue that is associated with the URL group. The structure can be used to remove an existing binding by setting this parameter to NULL.")]
	HANDLE RequestQueueHandle;

} HTTP_BINDING_INFO;

typedef HTTP_BINDING_INFO *PHTTP_BINDING_INFO;

typedef
[
	public, v1_enum,
	helpstring("Defines the protection level types for UrlGroups.")
]
enum _HTTP_PROTECTION_LEVEL_TYPE
{
	[helpstring("This option will allow edge (NAT) traversed traffic, i.e. Teredo for the UrlGroup, unless there is an admin rule that overwrites the application's intent.")]
	HttpProtectionLevelUnrestricted,

	[helpstring("This setting will ensure that edge (NAT) traversed traffic will not be allowed.")]
	HttpProtectionLevelEdgeRestricted,

	[helpstring("Below type is not supported by HTTP API.")]
	HttpProtectionLevelRestricted

} HTTP_PROTECTION_LEVEL_TYPE, *PHTTP_PROTECTION_LEVEL_TYPE;

typedef
[
	helpstring("Controls whether the associated UrlGroup Namespace should receive edge traversed traffic. By default this parameter is unspecified."),
	uuid(E1881388-D03E-4EA0-8E39-8F1439753299)
]
struct HTTP_PROTECTION_LEVEL_INFO
{
	HTTP_PROPERTY_FLAGS;
	HTTP_PROTECTION_LEVEL_TYPE Level;

} HTTP_PROTECTION_LEVEL_INFO;

typedef [public] HTTP_PROTECTION_LEVEL_INFO *PHTTP_PROTECTION_LEVEL_INFO;


typedef ULONGLONG      HTTP_OPAQUE_ID, *PHTTP_OPAQUE_ID;

typedef HTTP_OPAQUE_ID HTTP_REQUEST_ID, *PHTTP_REQUEST_ID;
typedef HTTP_OPAQUE_ID HTTP_CONNECTION_ID, *PHTTP_CONNECTION_ID;
typedef HTTP_OPAQUE_ID HTTP_RAW_CONNECTION_ID, *PHTTP_RAW_CONNECTION_ID;

typedef HTTP_OPAQUE_ID HTTP_URL_GROUP_ID, *PHTTP_URL_GROUP_ID;
typedef HTTP_OPAQUE_ID HTTP_SERVER_SESSION_ID, *PHTTP_SERVER_SESSION_ID;

#define HTTP_NULL_ID            (0ui64)

typedef
[
	helpstring("This structure defines a file byte range. If the Length field is HTTP_BYTE_RANGE_TO_EOF then the remainder of the file (everything after StartingOffset) is sent."),
	uuid(3426318C-022F-4DD9-9E4E-A04FEBF70A10)
]
struct HTTP_BYTE_RANGE
{
	[helpstring("Starting offset of the byte range.")]
	ULARGE_INTEGER StartingOffset;
	[helpstring("Size, in bytes, of the range. If this member is HTTP_BYTE_RANGE_TO_EOF, the range extends from the starting offset to the end of the file or data block.")]
	ULARGE_INTEGER Length;

} HTTP_BYTE_RANGE;

typedef [public] HTTP_BYTE_RANGE *PHTTP_BYTE_RANGE;

typedef
[
	helpstring("defines a version of the HTTP protocol that a request requires or a response provides."),
	uuid(F6A0C406-B01A-4701-AA8C-D4C1A0D2B1A5)
]
struct HTTP_VERSION
{
	[readonly, helpstring("Major version of the HTTP protocol.")]
	USHORT MajorVersion;
	[readonly, helpstring("Minor version of the HTTP protocol.")]
	USHORT MinorVersion;
} HTTP_VERSION;

typedef [public] HTTP_VERSION *PHTTP_VERSION;

typedef
[
	public, v1_enum,
	helpstring("The enum type for HTTP verbs.")
]
enum _HTTP_VERB
{
	HttpVerbUnparsed,
	HttpVerbUnknown,
	HttpVerbInvalid,
	HttpVerbOPTIONS,
	HttpVerbGET,
	HttpVerbHEAD,
	HttpVerbPOST,
	HttpVerbPUT,
	HttpVerbDELETE,
	HttpVerbTRACE,
	HttpVerbCONNECT,
	HttpVerbTRACK,
	HttpVerbMOVE,
	HttpVerbCOPY,
	HttpVerbPROPFIND,
	HttpVerbPROPPATCH,
	HttpVerbMKCOL,
	HttpVerbLOCK,
	HttpVerbUNLOCK,
	HttpVerbSEARCH,

	HttpVerbMaximum

} HTTP_VERB, *PHTTP_VERB;

typedef
[
	public, v1_enum,
	helpstring("Symbols for all HTTP/1.1 headers and other tokens. Notice request + response values overlap. See RFC 2616, HTTP/1.1, for further explanation of most of these headers.")
]
enum _HTTP_HEADER_ID
{
	HttpHeaderCacheControl = 0,		
	HttpHeaderConnection = 1,		
	HttpHeaderDate = 2,				
	HttpHeaderKeepAlive = 3,		
	HttpHeaderPragma = 4,			
	HttpHeaderTrailer = 5,			
	HttpHeaderTransferEncoding = 6, 
	HttpHeaderUpgrade = 7,			
	HttpHeaderVia = 8,				
	HttpHeaderWarning = 9,			

	HttpHeaderAllow = 10,			
	HttpHeaderContentLength = 11,   
	HttpHeaderContentType = 12,		
	HttpHeaderContentEncoding = 13, 
	HttpHeaderContentLanguage = 14, 
	HttpHeaderContentLocation = 15, 
	HttpHeaderContentMd5 = 16,		
	HttpHeaderContentRange = 17,	
	HttpHeaderExpires = 18,			
	HttpHeaderLastModified = 19,	

	// Request Headers

	HttpHeaderAccept = 20,			
	HttpHeaderAcceptCharset = 21,  
	HttpHeaderAcceptEncoding = 22, 
	HttpHeaderAcceptLanguage = 23, 
	HttpHeaderAuthorization = 24,  
	HttpHeaderCookie = 25,			
	HttpHeaderExpect = 26,			
	HttpHeaderFrom = 27,			
	HttpHeaderHost = 28,			
	HttpHeaderIfMatch = 29,			

	HttpHeaderIfModifiedSince = 30,
	HttpHeaderIfNoneMatch = 31,			
	HttpHeaderIfRange = 32,				
	HttpHeaderIfUnmodifiedSince = 33,  
	HttpHeaderMaxForwards = 34,			
	HttpHeaderProxyAuthorization = 35, 
	HttpHeaderReferer = 36,				
	HttpHeaderRange = 37,				
	HttpHeaderTe = 38,					
	HttpHeaderTranslate = 39,			

	HttpHeaderUserAgent = 40,

	HttpHeaderRequestMaximum = 41,

	// Response Headers

	HttpHeaderAcceptRanges = 20,
	HttpHeaderAge = 21,
	HttpHeaderEtag = 22,
	HttpHeaderLocation = 23,
	HttpHeaderProxyAuthenticate = 24,
	HttpHeaderRetryAfter = 25,
	HttpHeaderServer = 26,
	HttpHeaderSetCookie = 27,
	HttpHeaderVary = 28,
	HttpHeaderWwwAuthenticate = 29,

	HttpHeaderResponseMaximum = 30,

	HttpHeaderMaximum = 41

} HTTP_HEADER_ID, *PHTTP_HEADER_ID;


typedef
[
	helpstring("Structure defining format of a known HTTP header. Name is from HTTP_HEADER_ID."),
	uuid(787C501E-95B2-4A23-9F7C-2DD856B8D51D)
]
struct HTTP_KNOWN_HEADER
{
	[nonbrowsable, helpstring("Size in bytes of RawValue not including terminating null")] 
	USHORT RawValueLength;
	_Counted_String_Ptr_(RawValueLength) LPCSTR  pRawValue;

} HTTP_KNOWN_HEADER;

typedef [public] HTTP_KNOWN_HEADER *PHTTP_KNOWN_HEADER;

typedef
[
	helpstring("Structure defining format of an unknown header."),
	uuid(98A27339-73E3-4D54-BAF2-915B818916B1)
]
struct HTTP_UNKNOWN_HEADER
{
	[nonbrowsable, helpstring("Size in bytes of Name not including terminating null")] USHORT NameLength;
	[nonbrowsable, helpstring("Size in bytes of RawValue not including terminating null")] USHORT RawValueLength;
	[helpstring("The header name (minus the ':' character)")]
	_Counted_String_Ptr_(NameLength) LPCSTR  pName;
	[helpstring("The header value.")]
	_Counted_String_Ptr_(RawValueLength) LPCSTR  pRawValue;

} HTTP_UNKNOWN_HEADER;

typedef [public] HTTP_UNKNOWN_HEADER *PHTTP_UNKNOWN_HEADER;

typedef
[
	public, v1_enum,
	helpstring("Log fields data structure is used for logging a request. This structure must  be provided along with an HttpSendHttpResponse or HttpSendResponseEntityBody call that concludes the send.")
]
enum _HTTP_LOG_DATA_TYPE
{
	HttpLogDataTypeFields = 0

} HTTP_LOG_DATA_TYPE, *PHTTP_LOG_DATA_TYPE;

//typedef
//[
//	uuid(318F801A-36D7-4A2F-942B-02F1C861873C)
//]
//struct HTTP_LOG_DATA
//{
//	HTTP_LOG_DATA_TYPE Type;
//
//} HTTP_LOG_DATA;
//typedef [public] HTTP_LOG_DATA *PHTTP_LOG_DATA;

typedef
[
	helpstring("Current log fields data structure for of type HttpLogDataTypeFields."),
	uuid(35C62B99-ABF3-46F3-B967-7B54DC2641CC)
]
struct HTTP_LOG_FIELDS_DATA
{
	//HTTP_LOG_DATA Base;
	HTTP_LOG_DATA_TYPE Type;

	USHORT UserNameLength;
	USHORT UriStemLength;
	USHORT ClientIpLength;
	USHORT ServerNameLength;
	USHORT ServiceNameLength;
	USHORT ServerIpLength;
	USHORT MethodLength;
	USHORT UriQueryLength;
	USHORT HostLength;
	USHORT UserAgentLength;
	USHORT CookieLength;
	USHORT ReferrerLength;

	_Counted_String_Ptr_(UserNameLength) PWCHAR UserName;
	_Counted_String_Ptr_(UriStemLength) PWCHAR UriStem;
	_Counted_String_Ptr_(ClientIpLength) PCHAR  ClientIp;
	_Counted_String_Ptr_(ServerNameLength) PCHAR  ServerName;
	_Counted_String_Ptr_(ServiceNameLength) PCHAR  ServiceName;
	_Counted_String_Ptr_(ServerIpLength) PCHAR  ServerIp;
	_Counted_String_Ptr_(MethodLength) PCHAR  Method;
	_Counted_String_Ptr_(UriQueryLength) PCHAR  UriQuery;
	_Counted_String_Ptr_(HostLength) PCHAR  Host;
	_Counted_String_Ptr_(UserAgentLength) PCHAR  UserAgent;
	_Counted_String_Ptr_(CookieLength) PCHAR  Cookie;
	_Counted_String_Ptr_(ReferrerLength) PCHAR  Referrer;

	USHORT ServerPort;
	USHORT ProtocolStatus;

	ULONG  Win32Status;

	HTTP_VERB MethodNum;

	USHORT SubStatus;

} HTTP_LOG_FIELDS_DATA;
typedef [public] HTTP_LOG_FIELDS_DATA *PHTTP_LOG_FIELDS_DATA;

typedef [public] HTTP_LOG_FIELDS_DATA *PHTTP_LOG_DATA;

typedef
[
	public, v1_enum, /*, uuid(4146B9B1-7413-49ED-970D-55E9CC537639), */
	helpstring("This enum defines a data source for a particular chunk of data.")
]
enum _HTTP_DATA_CHUNK_TYPE
{
	HttpDataChunkFromMemory,
	HttpDataChunkFromFileHandle,
	HttpDataChunkFromFragmentCache,
	HttpDataChunkFromFragmentCacheEx,

	HttpDataChunkMaximum

} HTTP_DATA_CHUNK_TYPE;


typedef
[
	helpstring("This structure describes an individual data chunk."),
	uuid(831E8135-6BB5-45E2-B278-10B1C489883A)
]
struct HTTP_DATA_CHUNK
{
	[helpstring("The type of this data chunk.")]
	HTTP_DATA_CHUNK_TYPE DataChunkType;

	[helpstring("The data chunk structures, one per supported data chunk type.")]
	union
	{
		[helpstring("From-memory data chunk.")]
		struct
		{
			PVOID pBuffer;
			ULONG BufferLength;

		} FromMemory;

		[helpstring("From-file handle data chunk.")]
		struct
		{
			HTTP_BYTE_RANGE ByteRange;
			HANDLE          FileHandle;

		} FromFileHandle;

		[helpstring("From-fragment cache data chunk.")]
		struct
		{
			[helpstring("Size in bytes of FragmentName not including terminating null")]
			USHORT FragmentNameLength;
			PCWSTR pFragmentName;

		} FromFragmentCache;

		[helpstring("From-fragment cache data chunk that specifies a byte range.")]
		struct
		{
			HTTP_BYTE_RANGE ByteRange;
			[helpstring("Null-terminated string")]
			PCWSTR pFragmentName;

		} FromFragmentCacheEx;

	};

} HTTP_DATA_CHUNK;

typedef HTTP_DATA_CHUNK *PHTTP_DATA_CHUNK;

typedef 
[
	uuid(739d04bb-0a15-47ea-8a7d-20b4fd31cc96),
	helpstring("Fields common to HTTP_REQUEST_HEADERS and HTTP_RESPONSE_HEADERS")
]
struct HTTP_HEADERS
{
	[nonbrowsable, helpstring("The number of entries in the UnknownHeaders array.")]
	USHORT               UnknownHeaderCount;
	[helpstring("The array of unknown HTTP headers.")]
	_Counted_Array_Ptr_(UnknownHeaderCount) PHTTP_UNKNOWN_HEADER pUnknownHeaders;

	_Reserved_ [nonbrowsable] USHORT               TrailerCount;
	_Reserved_ _Counted_Array_Ptr_(TrailerCount) PHTTP_UNKNOWN_HEADER pTrailers;

} HTTP_HEADERS;

typedef
[
	uuid(F762B6AC-F56F-4AEB-ACA3-D6B628473C2C),
	helpstring("Structure defining format of request headers.")
]
struct HTTP_REQUEST_HEADERS
{
	HTTP_HEADERS;
	
	[helpstring("Known request headers.")]
	HTTP_KNOWN_HEADER    KnownHeaders[HttpHeaderRequestMaximum];

} HTTP_REQUEST_HEADERS;

typedef HTTP_REQUEST_HEADERS *PHTTP_REQUEST_HEADERS;

typedef
[
	helpstring("Structure defining format of response headers."),
	uuid(487FD2E3-1549-4DCF-8703-D45A2CBBCD85)
]
struct HTTP_RESPONSE_HEADERS
{
	HTTP_HEADERS;

	[helpstring("Known response headers.")]
	HTTP_KNOWN_HEADER    KnownHeaders[HttpHeaderResponseMaximum];

} HTTP_RESPONSE_HEADERS;

typedef [public] HTTP_RESPONSE_HEADERS *PHTTP_RESPONSE_HEADERS;

typedef
[
	uuid(F0489E13-59AB-4951-8E32-1159AA1D6C90),
	helpstring("Structure defining format of transport address. Use pLocalAddress->sa_family to determine whether this is an IPv4 address (AF_INET) or IPv6 (AF_INET6). pRemoteAddress->sa_family will be the same as pLocalAddress->sa_family.")
]
//struct HTTP_TRANSPORT_ADDRESS
//{
//	PSOCKADDR      pRemoteAddress;
//	PSOCKADDR      pLocalAddress;
//
//} HTTP_TRANSPORT_ADDRESS;
PSOCKADDR HTTP_TRANSPORT_ADDRESS[2];
typedef [public] HTTP_TRANSPORT_ADDRESS *PHTTP_TRANSPORT_ADDRESS;

typedef
[
	helpstring("The HTTP_COOKED_URL structure contains a validated, canonical, UTF-16 Unicode-encoded URL request string together with pointers into it and element lengths."),
	uuid(24928162-1798-46A3-B2C1-3C6EE66C08BE)
]
struct HTTP_COOKED_URL
{
	[nonbrowsable, helpstring("Size, in bytes, of the data pointed to by the pFullUrl member, not including a terminating null character.")]
	_ReadOnly_ USHORT FullUrlLength;       // in bytes not including the NUL
	[nonbrowsable, helpstring("Size, in bytes, of the data pointed to by the pHost member, not including a terminating null character.")]
	_ReadOnly_ USHORT HostLength;          // in bytes (no NUL)
	[nonbrowsable, helpstring("Size, in bytes, of the data pointed to by the pAbsPath member, not including a terminating null character.")]
	_ReadOnly_ USHORT AbsPathLength;       // in bytes (no NUL)
	[nonbrowsable, helpstring("Size, in bytes, of the data pointed to by the pQueryString member, not including a terminating null character.")]
	_ReadOnly_ USHORT QueryStringLength;   // in bytes (no NUL)

	[helpstring("Pointer to the scheme element at the beginning of the URL (must be either 'http://...' or 'https://...').")]
	_ReadOnly_ _Counted_String_Ptr_(FullUrlLength/2) PCWSTR pFullUrl;     // points to "http://hostname:port/abs/.../path?query"
	[helpstring("Pointer to the first character in the host element, immediately following the double slashes at the end of the scheme element.")]
	_ReadOnly_ _Counted_String_Ptr_(HostLength>>1) PCWSTR pHost;        // points to the first char in the hostname
	[helpstring("Pointer to the third forward slash ('/') in the string. In a UrlPrefix string, this is the slash immediately preceding the relativeUri element.")]
	_ReadOnly_ _Counted_String_Ptr_(AbsPathLength>>1) PCWSTR pAbsPath;     // Points to the 3rd '/' char
	[helpstring("Pointer to the first question mark (?) in the string, or NULL if there is none.")]
	_ReadOnly_ _Counted_String_Ptr_(QueryStringLength>>1) PCWSTR pQueryString; // Points to the 1st '?' char or NULL

} HTTP_COOKED_URL;

typedef [public] HTTP_COOKED_URL *PHTTP_COOKED_URL;

[helpstring("An opaque context for URL manipulation.")]
typedef ULONGLONG HTTP_URL_CONTEXT;

typedef
[
	public, v1_enum,
	helpstring("Request Authentication related.")
]
enum _HTTP_AUTH_STATUS
{
	HttpAuthStatusSuccess,
	HttpAuthStatusNotAuthenticated,
	HttpAuthStatusFailure

} HTTP_AUTH_STATUS, *PHTTP_AUTH_STATUS;


typedef 
[
	public, v1_enum
]
enum _HTTP_REQUEST_AUTH_TYPE
{
	HttpRequestAuthTypeNone = 0,
	HttpRequestAuthTypeBasic,
	HttpRequestAuthTypeDigest,
	HttpRequestAuthTypeNTLM,
	HttpRequestAuthTypeNegotiate,
	HttpRequestAuthTypeKerberos
} HTTP_REQUEST_AUTH_TYPE, *PHTTP_REQUEST_AUTH_TYPE;


typedef
[
	helpstring("SSL Client certificate information."),
	uuid(2EA1D77C-9411-49F7-AF99-3554A22FE89E)
]
struct HTTP_SSL_CLIENT_CERT_INFO
{
	[helpstring("Flags that indicate whether the certificate is valid. ")]
	ULONG   CertFlags;
	[nonbrowsable, helpstring("The size, in bytes, of the certificate")]
	ULONG   CertEncodedSize;
	[helpstring("A pointer to the actual certificate.")]
	_Counted_Array_Ptr_(CertEncodedSize) PUCHAR  pCertEncoded;
	[helpstring("A handle to an access token.")]
	HANDLE  Token;
	_Reserved_
	BOOLEAN CertDeniedByMapper;

} HTTP_SSL_CLIENT_CERT_INFO;

typedef [public] HTTP_SSL_CLIENT_CERT_INFO *PHTTP_SSL_CLIENT_CERT_INFO;

typedef
[
	helpstring("Data computed during SSL handshake."),
	uuid(FD0D6F69-8AFE-4748-A88B-9FB70593DFC8)
]
struct HTTP_SSL_INFO
{
	[helpstring("The size, in bytes, of the public key used to sign the server certificate.")]
	USHORT ServerCertKeySize;
	[helpstring("The size, in bytes, of the cipher key used to encrypt the current session.")]
	USHORT ConnectionKeySize;
	[nonbrowsable, helpstring("The size, in bytes, of the string pointed to by the pServerCertIssuer member not including the terminating null character.")]
	ULONG  ServerCertIssuerSize;
	[nonbrowsable, helpstring("The size, in bytes, of the string pointed to by the pServerCertSubject member not including the terminating null character.")]
	ULONG  ServerCertSubjectSize;

	[helpstring("A pointer to a null-terminated string of octets that specifies the name of the entity that issued the certificate.")]
	_Counted_Array_Ptr_(ServerCertIssuerSize) LPCSTR  pServerCertIssuer;
	[helpstring("A pointer to a null-terminated string of octets that specifies the name of the entity to which the certificate belongs.")]
	_Counted_Array_Ptr_(ServerCertSubjectSize) LPCSTR  pServerCertSubject;

	[helpstring("A pointer to an HTTP_SSL_CLIENT_CERT_INFO structure that specifies the client certificate.")]
	PHTTP_SSL_CLIENT_CERT_INFO pClientCertInfo;
	[helpstring("If non-zero, indicates that the client certificate is already present locally.")]
	ULONG SslClientCertNegotiated;

} HTTP_SSL_INFO;
typedef HTTP_SSL_INFO *PHTTP_SSL_INFO;

typedef
[
	helpstring("HttpRequestInfoTypeSslProtocol payload. Contains basic information about the SSL/TLS protocol and cipher. See SecPkgContext_ConnectionInfo documentation for details."),
	uuid(73784AFD-F4E5-464E-B716-46EBB0C8C6D1)
]
struct HTTP_SSL_PROTOCOL_INFO
{
	[readonly] ULONG Protocol;
	[readonly] ULONG CipherType;
	[readonly] ULONG CipherStrength;
	[readonly] ULONG HashType;
	[readonly] ULONG HashStrength;
	[readonly] ULONG KeyExchangeType;
	[readonly] ULONG KeyExchangeStrength;

} HTTP_SSL_PROTOCOL_INFO;
typedef [public] HTTP_SSL_PROTOCOL_INFO *PHTTP_SSL_PROTOCOL_INFO;


typedef
[
	public, v1_enum,
	helpstring("Generic request information type.")
]
enum _HTTP_REQUEST_INFO_TYPE
{
	HttpRequestInfoTypeAuth,
	HttpRequestInfoTypeChannelBind,
	HttpRequestInfoTypeSslProtocol,
	HttpRequestInfoTypeSslTokenBinding

} HTTP_REQUEST_INFO_TYPE, *PHTTP_REQUEST_INFO_TYPE;

typedef
[
	uuid(8C37D370-DA00-4186-B515-EBE6B57D8CC6)
]
struct HTTP_REQUEST_INFO
{
	[nonbrowsable, helpstring("A member of the HTTP_REQUEST_INFO_TYPE enumeration specifying the type of information contained in this structure.")]
	HTTP_REQUEST_INFO_TYPE InfoType;
	[nonbrowsable, helpstring("The length, in bytes, of the pInfo member.")]
	ULONG                  InfoLength;
	[nonbrowsable, helpstring("The request info data")]
	_Counted_Array_Ptr_(InfoLength) PVOID                  pInfo;

} HTTP_REQUEST_INFO;
typedef [public] HTTP_REQUEST_INFO *PHTTP_REQUEST_INFO;

typedef LONG SECURITY_STATUS;

typedef
[
	helpstring("Authentication request info structure"),
	uuid(E0696C2E-1353-45E2-BDCC-A52B6142B827)
]
struct HTTP_REQUEST_AUTH_INFO
{
	[helpstring("A member of the HTTP_AUTH_STATUS enumeration that indicates the final authentication status of the request.")]
	HTTP_AUTH_STATUS AuthStatus;
	[helpstring("A SECURITY_STATUS value that indicates the security failure status when the AuthStatus member is HttpAuthStatusFailure.")]
	SECURITY_STATUS  SecStatus;

	[helpstring("Flags from the HTTP_REQUEST_AUTH_FLAG_ enumeration.")]
	ULONG Flags;

	[helpstring("A member of the HTTP_REQUEST_AUTH_TYPE enumeration that indicates the authentication scheme attempted or established for the request.")]
	HTTP_REQUEST_AUTH_TYPE AuthType;

	[helpstring("A handle to the client token that the receiving process can use to impersonate the authenticated client. The handle to the token should be closed by calling CloseHandle when it is no longer required.")]
	HANDLE AccessToken;
	[helpstring("The client context attributes for the access token.")]
	ULONG ContextAttributes;

	[nonbrowsable, helpstring("The length, in bytes, of the PackedContext.")]
	ULONG PackedContextLength;
	[helpstring("The type of context in the PackedContext member.")]
	ULONG PackedContextType;
	[helpstring("The security context for the authentication type.")]
	_Field_size_bytes_(PackedContextLength) PVOID PackedContext;

	[nonbrowsable, helpstring("The length, in bytes, of the pMutualAuthData member.")]
	ULONG MutualAuthDataLength;
	[helpstring("The Base64 encoded mutual authentication data used in the WWW-Authenticate header.")]
	_Counted_String_Ptr_(MutualAuthDataLength) PCHAR pMutualAuthData;

	[nonbrowsable, helpstring("For SSPI based schemes the package name is returned. Length does not include the terminating null and it is in bytes.")]
	USHORT PackageNameLength;
	_Counted_String_Ptr_(PackageNameLength>>1) PWSTR pPackageName;

} HTTP_REQUEST_AUTH_INFO;

typedef HTTP_REQUEST_AUTH_INFO *PHTTP_REQUEST_AUTH_INFO;

typedef
[
	helpstring("Represents an incoming HTTP request (N.B. this is the V1, pre-Vista, structure)"),
	uuid(7927a79c-8c4e-423a-bf24-f1b36b4df5c4)
]
struct HTTP_REQUEST_V1
{
	[helpstring("Request flags (see HTTP_REQUEST_FLAG_* definitions below).")]
	ULONG Flags;

	[helpstring("An opaque request identifier. These values are used by the driver to correlate outgoing responses with incoming requests.")]
	HTTP_CONNECTION_ID ConnectionId;
	HTTP_REQUEST_ID    RequestId;

	[helpstring("The context associated with the URL prefix.")]
	HTTP_URL_CONTEXT UrlContext;

	[helpstring("The HTTP protocol version number.")]
	HTTP_VERSION Version;

	[helpstring("An HTTP verb associated with this request. This member can be one of the values from the HTTP_VERB enumeration.")]
	HTTP_VERB Verb;

	[nonbrowsable, helpstring("The length of the verb string if the Verb field is HttpVerbUnknown. In bytes not including the NUL")]
	USHORT UnknownVerbLength;

	[nonbrowsable, helpstring("The length of the raw (uncooked) URL in bytes not including the NUL")]
	USHORT RawUrlLength;

	[helpstring("Pointer to the verb string if the Verb field is HttpVerbUnknown.")]
	_Counted_String_Ptr_(UnknownVerbLength) LPCSTR  pUnknownVerb;

	[nonbrowsable, helpstring("Pointer to the raw (uncooked) URL")]
	_Counted_String_Ptr_(RawUrlLength) LPCSTR  pRawUrl;

	[helpstring("The canonicalized Unicode URL")]
	HTTP_COOKED_URL CookedUrl;

	[helpstring("Local and remote transport addresses for the connection.")]
	HTTP_TRANSPORT_ADDRESS Address;

	[helpstring("The request headers.")]
	HTTP_REQUEST_HEADERS Headers;

	[helpstring("The total number of bytes received from network for this request.")]
	ULONGLONG BytesReceived;

	[nonbrowsable, helpstring("The number of elements in the pEntityChunks array. If no entity body was copied, this value is zero.")] 
	USHORT EntityChunkCount;
	[helpstring("pEntityChunks is an array of EntityChunkCount HTTP_DATA_CHUNKs. The entity body is copied only if HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY was passed to HttpReceiveHttpRequest().")]
	_Counted_Array_Ptr_(EntityChunkCount) PHTTP_DATA_CHUNK pEntityChunks;

	[helpstring("Raw connection ID for an Secure Sockets Layer (SSL) request.")]
	HTTP_RAW_CONNECTION_ID RawConnectionId;
	[helpstring("A pointer to an HTTP_SSL_INFO structure that contains Secure Sockets Layer (SSL) information about the connection on which the request was received.")]
	PHTTP_SSL_INFO         pSslInfo;
} HTTP_REQUEST_V1;

typedef
[
	helpstring("Represents an incoming HTTP request (N.B. this is the V2, Vista and later, structure)"),
	uuid(5F3F936F-B824-47AF-A69E-62DC4730010C)
]
struct HTTP_REQUEST_V2
{
	HTTP_REQUEST_V1;

	// Fields added in Vista

	[nonbrowsable, helpstring("The number of HTTP_REQUEST_INFO structures in the array pointed to by pRequestInfo.")]
	USHORT             RequestInfoCount;
	[helpstring("A pointer to an array of HTTP_REQUEST_INFO structures that contains additional information about the request.")]
	_Counted_Array_Ptr_(RequestInfoCount) PHTTP_REQUEST_INFO pRequestInfo;

} HTTP_REQUEST_V2;

typedef [public]HTTP_REQUEST_V2 HTTP_REQUEST;
typedef HTTP_REQUEST *PHTTP_REQUEST;

typedef [v1_enum] enum _HTTP_RESPONSE_INFO_TYPE
{
	HttpResponseInfoTypeMultipleKnownHeaders,
	HttpResponseInfoTypeAuthenticationProperty,
	HttpResponseInfoTypeQoSProperty,
	HttpResponseInfoTypeChannelBind

} HTTP_RESPONSE_INFO_TYPE, PHTTP_RESPONSE_INFO_TYPE;

typedef
[
	uuid(CDF58C2C-140F-4611-B847-12837CE3155F)
]
struct HTTP_RESPONSE_INFO
{
	[nonbrowsable, helpstring("A member of the HTTP_RESPONSE_INFO_TYPE enumeration specifying the type of information contained in this structure.")]
	HTTP_RESPONSE_INFO_TYPE Type;
	[nonbrowsable, helpstring("Length in bytes of the data pointed at by pInfo.")]
	ULONG                   Length;
	[nonbrowsable, helpstring("Response information data")]
	_Counted_Array_Ptr_(Length) PVOID                   pInfo;
} HTTP_RESPONSE_INFO;

typedef HTTP_RESPONSE_INFO *PHTTP_RESPONSE_INFO;

typedef
[
	helpstring("This structure describes an HTTP response (V1)."),
	uuid(c23ac8a9-b97f-4aec-8096-91648573c429)
]
struct HTTP_RESPONSE_V1
{
	[helpstring("Response flags from the HTTP_RESPONSE_FLAGS_* constants.")]
	ULONG Flags;

	[helpstring("The raw HTTP protocol version number.")]
	HTTP_VERSION Version;

	[helpstring("The HTTP status code (e.g., 200).")]
	USHORT StatusCode;

	[nonbrowsable] USHORT ReasonLength;                 // in bytes not including the '\0'
	[helpstring("The HTTP reason (e.g., 'OK'). This MUST not contain non-ASCII characters (i.e., all chars must be in range 0x20-0x7E).")]
	_Counted_String_Ptr_(ReasonLength) LPCSTR  pReason;

	[helpstring("The response headers.")]
	HTTP_RESPONSE_HEADERS Headers;

	[nonbrowsable]
	USHORT           EntityChunkCount;
	[helpstring("pEntityChunks points to an array of EntityChunkCount HTTP_DATA_CHUNKs.")]
	_Counted_Array_Ptr_(EntityChunkCount) PHTTP_DATA_CHUNK pEntityChunks;
} HTTP_RESPONSE_V1;

typedef
[
	helpstring("This structure describes an HTTP response (V2)."),
	uuid(5E3A97DA-7345-49A7-A5A9-1DDEA2366EB2)
]
struct HTTP_RESPONSE_V2
{
	HTTP_RESPONSE_V1;

	[nonbrowsable] USHORT ResponseInfoCount;
	_Counted_Array_Ptr_(ResponseInfoCount) PHTTP_RESPONSE_INFO pResponseInfo;
} HTTP_RESPONSE_V2;

typedef [public] HTTP_RESPONSE_V2 HTTP_RESPONSE;

typedef
[
	helpstring("This structure allows the provision of providing multiple known headers."),
	uuid(A12486B1-FDF5-4D31-A4B7-AF9848FFE5C6)
]
struct HTTP_MULTIPLE_KNOWN_HEADERS
{
	[helpstring("Known header id.")]
	HTTP_HEADER_ID      HeaderId;

	[helpstring("The flags corresponding to the response header in the HeaderId member. This member is used only when the WWW-Authenticate header is present.")]
	ULONG               Flags;

	[helpstring("The number of elements in the array specified in the KnownHeaders member.")]
	USHORT              KnownHeaderCount;

	[helpstring("A pointer to the first element in the array of HTTP_KNOWN_HEADER structures.")]
	_Counted_Array_Ptr_(KnownHeaderCount) PHTTP_KNOWN_HEADER  KnownHeaders;

} HTTP_MULTIPLE_KNOWN_HEADERS;
typedef [public] HTTP_MULTIPLE_KNOWN_HEADERS *PHTTP_MULTIPLE_KNOWN_HEADERS;

typedef [public] HTTP_RESPONSE *PHTTP_RESPONSE;

typedef
[
	helpstring("Api Version. This is used to ensure compatibility between applications and httpapi.dll and http.sys. This should not be confused with the HTTP Protocol version."),
	uuid(61D915C6-278B-4ED6-942B-DB3B81C86C11)
]

//struct HTTPAPI_VERSION
//{
//	USHORT HttpApiMajorVersion;
//	USHORT HttpApiMinorVersion;
//
//} 
DWORD HTTPAPI_VERSION;
typedef [public] HTTPAPI_VERSION *PHTTPAPI_VERSION;

typedef
[
	public, v1_enum,
	helpstring("This enum defines the available cache policies.")
]
enum _HTTP_CACHE_POLICY_TYPE
{
	HttpCachePolicyNocache,
	HttpCachePolicyUserInvalidates,
	HttpCachePolicyTimeToLive,

	HttpCachePolicyMaximum

} HTTP_CACHE_POLICY_TYPE, *PHTTP_CACHE_POLICY_TYPE;


typedef
[
	helpstring(" Only cache unauthorized GETs + HEADs."),
	uuid(02064551-C601-4E48-85AC-6D19FE34F58B)
]
struct HTTP_CACHE_POLICY
{
	HTTP_CACHE_POLICY_TYPE  Policy;
	ULONG                   SecondsToLive;

} HTTP_CACHE_POLICY;
typedef [public] HTTP_CACHE_POLICY *PHTTP_CACHE_POLICY;

typedef
[
	public, v1_enum,
	helpstring("Enum that is used with HttpSetServiceConfiguration(), HttpQueryServiceConfiguration(), and HttpDeleteServiceConfiguration() APIs.")
]
enum _HTTP_SERVICE_CONFIG_ID
{
	HttpServiceConfigIPListenList,    // Set, Query & Delete.
	HttpServiceConfigSSLCertInfo,     // Set, Query & Delete.
	HttpServiceConfigUrlAclInfo,      // Set, Query & Delete.
	HttpServiceConfigTimeout,         // Set, Query & Delete.
	HttpServiceConfigCache,           // Set, Query & Delete.

	HttpServiceConfigSslSniCertInfo,  // Win8: Set, Query & Delete.
	HttpServiceConfigSslCcsCertInfo,  // Win8: Set, Query & Delete.

	HttpServiceConfigMax

} HTTP_SERVICE_CONFIG_ID, *PHTTP_SERVICE_CONFIG_ID;

typedef
[
	public, v1_enum,
	helpstring("Generic Query enum that can be used with HttpQueryServiceConfiguration()")
]
enum _HTTP_SERVICE_CONFIG_QUERY_TYPE
{
	HttpServiceConfigQueryExact,
	HttpServiceConfigQueryNext,
	HttpServiceConfigQueryMax

} HTTP_SERVICE_CONFIG_QUERY_TYPE, *PHTTP_SERVICE_CONFIG_QUERY_TYPE;

typedef
[
	helpstring("These data structures are used to define the key types of the various SSL bindings."),
	uuid(1B197959-4571-4CB1-AF19-6728D6BA0A55)
]
//struct HTTP_SERVICE_CONFIG_SSL_KEY
//{
//	PSOCKADDR pIpPort;
//} 
PSOCKADDR HTTP_SERVICE_CONFIG_SSL_KEY;

typedef [public] HTTP_SERVICE_CONFIG_SSL_KEY *PHTTP_SERVICE_CONFIG_SSL_KEY;

typedef
[
	uuid(32358DE8-2F95-48E9-8B5E-72900A0E6F36)
]
struct HTTP_SERVICE_CONFIG_SSL_SNI_KEY
{
	SOCKADDR_STORAGE IpPort;
	PWSTR Host;
} HTTP_SERVICE_CONFIG_SSL_SNI_KEY;
typedef [public] HTTP_SERVICE_CONFIG_SSL_SNI_KEY *PHTTP_SERVICE_CONFIG_SSL_SNI_KEY;

typedef
[
	uuid(1958EA2F-3B8B-4F4D-8E13-EC488AFB2BF0)
]
//struct HTTP_SERVICE_CONFIG_SSL_CCS_KEY
//{
//	SOCKADDR_STORAGE LocalAddress;
//} 
SOCKADDR_STORAGE HTTP_SERVICE_CONFIG_SSL_CCS_KEY;
	
typedef [public] HTTP_SERVICE_CONFIG_SSL_CCS_KEY *PHTTP_SERVICE_CONFIG_SSL_CCS_KEY;


typedef
[
	helpstring("This defines a record for the SSL config store."),
	uuid(7FE46AEF-BB33-40AC-A388-846C53EFDE1D)
]
struct HTTP_SERVICE_CONFIG_SSL_PARAM
{
	[nonbrowsable, helpstring("The size, in bytes, of the SSL hash.")]
	ULONG SslHashLength;
	[helpstring("A pointer to the SSL certificate hash.")]
	_Counted_Array_Ptr_(SslHashLength) PVOID pSslHash;
	[helpstring("A unique identifier of the application setting this record.")]
	GUID  AppId;
	[helpstring("A pointer to a wide-character string that contains the name of the store from which the server certificate is to be read. If set to NULL, \"MY\" is assumed as the default name.")]
	PWSTR  pSslCertStoreName;

	[helpstring("Flags determining how client certificates are checked.")]
	DWORD  DefaultCertCheckMode;

	[helpstring("DefaultRevocationFreshnessTime (seconds) - How often to check for an updated Certificate revocation list (CRL). If this value is 0 then the new CRL is updated only if the previous one expires")]
	DWORD  DefaultRevocationFreshnessTime;

	[helpstring("DefaultRevocationUrlRetrievalTimeout (milliseconds) - Timeout on attempt to retrieve certificate revocation list from the remote URL.")]
	DWORD  DefaultRevocationUrlRetrievalTimeout;

	[helpstring("pDefaultSslCtlIdentifier - Restrict the certificate issuers that you want to trust. Can be a subset of the certificate issuers that are trusted by the machine.")]
	PWSTR  pDefaultSslCtlIdentifier;

	[helpstring("Store name under LOCAL_MACHINE where Ctl identified by pDefaultSslCtlIdentifier is stored.")]
	PWSTR  pDefaultSslCtlStoreName;

	[helpstring("Default Flags - see HTTP_SERVICE_CONFIG_SSL_FLAG* below.")]
	DWORD  DefaultFlags;

} HTTP_SERVICE_CONFIG_SSL_PARAM;
	
typedef [public] HTTP_SERVICE_CONFIG_SSL_PARAM *PHTTP_SERVICE_CONFIG_SSL_PARAM;

typedef
[
	helpstring("Used by HttpSetServiceConfiguration() to add a new HttpServiceConfigSSLCertInfo record to the SSL bindings list"),
	uuid(F2C9434B-739E-4905-BCF3-D552724F69FF)
]
struct HTTP_SERVICE_CONFIG_SSL_SET
{
	HTTP_SERVICE_CONFIG_SSL_KEY     KeyDesc;
	HTTP_SERVICE_CONFIG_SSL_PARAM   ParamDesc;
} HTTP_SERVICE_CONFIG_SSL_SET;
	
typedef HTTP_SERVICE_CONFIG_SSL_SET *PHTTP_SERVICE_CONFIG_SSL_SET;

typedef
[
	helpstring("Used by HttpSetServiceConfiguration() to add a new HttpServiceConfigSslSniCertInfo record to the SSL bindings list"),
	uuid(4C2FB659-18F1-4258-BEB7-2283ED27E94B)
]
struct HTTP_SERVICE_CONFIG_SSL_SNI_SET
{
	HTTP_SERVICE_CONFIG_SSL_SNI_KEY KeyDesc;
	HTTP_SERVICE_CONFIG_SSL_PARAM   ParamDesc;
} HTTP_SERVICE_CONFIG_SSL_SNI_SET;
	
typedef HTTP_SERVICE_CONFIG_SSL_SNI_SET *PHTTP_SERVICE_CONFIG_SSL_SNI_SET;

typedef
[
	helpstring("Used by HttpSetServiceConfiguration() to add a new HttpServiceConfigSslCcsCertInfo record to the SSL bindings list"),
	uuid(078985F7-29B2-4403-8ACF-074217E6E9F4)
]
struct HTTP_SERVICE_CONFIG_SSL_CCS_SET
{
	HTTP_SERVICE_CONFIG_SSL_CCS_KEY KeyDesc;
	HTTP_SERVICE_CONFIG_SSL_PARAM   ParamDesc;
} HTTP_SERVICE_CONFIG_SSL_CCS_SET;
	
typedef HTTP_SERVICE_CONFIG_SSL_CCS_SET *PHTTP_SERVICE_CONFIG_SSL_CCS_SET;

typedef 
[
	uuid(38f6548e-ee39-4262-9f31-96ce0e8c6cb7)
]
struct HttpServiceConfigQuery
{
	HTTP_SERVICE_CONFIG_QUERY_TYPE  QueryDesc;
} HttpServiceConfigQuery;

typedef
[
	helpstring("Used with HttpQueryServiceConfiguration() to query a HttpServiceConfigSSLCertInfo record from the SSL store."),
	uuid(D0A38BB4-BA56-4DC6-9079-AC7694EF98AC)
]
struct HTTP_SERVICE_CONFIG_SSL_QUERY
{
	HttpServiceConfigQuery;
	HTTP_SERVICE_CONFIG_SSL_KEY     KeyDesc;
	DWORD                           dwToken;
} HTTP_SERVICE_CONFIG_SSL_QUERY;
	
typedef HTTP_SERVICE_CONFIG_SSL_QUERY *PHTTP_SERVICE_CONFIG_SSL_QUERY;

typedef
[
	helpstring("Used with HttpQueryServiceConfiguration() to query a HttpServiceConfigSSLSniCertInfo record from the SSL store."),
	uuid(4D8CBFDF-8766-4E01-A7F0-C775406DD04C)
]
struct HTTP_SERVICE_CONFIG_SSL_SNI_QUERY
{
	HttpServiceConfigQuery;
	HTTP_SERVICE_CONFIG_SSL_SNI_KEY KeyDesc;
	DWORD                           dwToken;
} HTTP_SERVICE_CONFIG_SSL_SNI_QUERY;
	
typedef HTTP_SERVICE_CONFIG_SSL_SNI_QUERY *PHTTP_SERVICE_CONFIG_SSL_SNI_QUERY;

typedef
[
	helpstring("Used with HttpQueryServiceConfiguration() to query a HttpServiceConfigSslCcsCertInfo record from the SSL store."),
	uuid(D6A678D5-678E-4BF6-AB65-77C8E6A641A9)
]
struct HTTP_SERVICE_CONFIG_SSL_CCS_QUERY
{
	HttpServiceConfigQuery;
	HTTP_SERVICE_CONFIG_SSL_CCS_KEY KeyDesc;
	DWORD                           dwToken;
} HTTP_SERVICE_CONFIG_SSL_CCS_QUERY;
	
typedef HTTP_SERVICE_CONFIG_SSL_CCS_QUERY *PHTTP_SERVICE_CONFIG_SSL_CCS_QUERY;
	
typedef
[
	helpstring("Set/Delete IP Listen-Only List record. Used as a parameter to both HttpSetServiceConfiguration() and HttpDeleteServiceConfiguration() functions."),
	uuid(00A93E39-C011-4A5B-AF4D-13F2DF7A38D4)
]
struct HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM
{
	[nonbrowsable, helpstring("The size, in bytes, of the address pointed to by pAddress.")]
	USHORT      AddrLength;
	[helpstring("A pointer to an Internet Protocol (IP) address to be added to or deleted from the listen list.")]
	PSOCKADDR   pAddress;
} HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM;
typedef HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM *PHTTP_SERVICE_CONFIG_IP_LISTEN_PARAM;

typedef
[
	helpstring("Query IP Listen-Only List record. Parameter to HttpQueryServiceConfiguration() for the config ID HttpServiceConfigIPListenList."),
	uuid(3EEBCB9D-9DC3-4701-A044-C16DF022085B)
]
struct HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY
{
	[nonbrowsable, helpstring("The number of address structures in the AddrList array.")]
	ULONG              AddrCount;
	[helpstring("An array of SOCKADDR_STORAGE structures that contains IP addresses in either IPv4 or IPv6 form. To determine what form an address in the list has, cast it to a SOCKADDR and examine the sa_family element.")]
	_Counted_Array_(AddrCount)
	SOCKADDR_STORAGE   AddrList[ANYSIZE_ARRAY];
} HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY;
	
typedef HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY *PHTTP_SERVICE_CONFIG_IP_LISTEN_QUERY;

typedef
[
	helpstring("URL ACL"),
	uuid(5A98E5AE-54DA-40BF-9DE7-FA90ACB6E27C)
]
//struct HTTP_SERVICE_CONFIG_URLACL_KEY
//{
//	PWSTR pUrlPrefix;
//
//} 
PWSTR
HTTP_SERVICE_CONFIG_URLACL_KEY;
typedef HTTP_SERVICE_CONFIG_URLACL_KEY *PHTTP_SERVICE_CONFIG_URLACL_KEY;

typedef
[
	helpstring(" used to specify the permissions associated with a particular record in the URL namespace reservation store. It is a member of the HTTP_SERVICE_CONFIG_URLACL_SET structure."),
	uuid(8E85EDB8-AA68-4FB2-9982-565C833B1478)
]
//struct HTTP_SERVICE_CONFIG_URLACL_PARAM
//{
//	PWSTR pStringSecurityDescriptor;
//} 
PWSTR HTTP_SERVICE_CONFIG_URLACL_PARAM;
	
typedef [public] HTTP_SERVICE_CONFIG_URLACL_PARAM *PHTTP_SERVICE_CONFIG_URLACL_PARAM;


typedef
[
	helpstring("This data structure is used by HttpSetServiceConfiguration for the config ID HttpServiceConfigUrlAclInfo.It is used to add a new record to the URL ACL store."),
	uuid(8144C4CA-DFD3-4ED0-A83B-AD096BD611A4)
]
struct HTTP_SERVICE_CONFIG_URLACL_SET
{
	HTTP_SERVICE_CONFIG_URLACL_KEY   KeyDesc;
	HTTP_SERVICE_CONFIG_URLACL_PARAM ParamDesc;
} HTTP_SERVICE_CONFIG_URLACL_SET;
	
typedef [public] HTTP_SERVICE_CONFIG_URLACL_SET *PHTTP_SERVICE_CONFIG_URLACL_SET;


typedef
[
	helpstring("This data structure is used by HttpQueryServiceConfiguration() for the	config ID HttpServiceConfigUrlAclInfo to query records from the URL ACL store."),
	uuid(FBE6F060-F472-445E-B48C-9CAA8FAEDC7E)
]
struct HTTP_SERVICE_CONFIG_URLACL_QUERY
{
	HttpServiceConfigQuery;
	HTTP_SERVICE_CONFIG_URLACL_KEY  KeyDesc;
	DWORD                           dwToken;
} HTTP_SERVICE_CONFIG_URLACL_QUERY;
	
typedef [public] HTTP_SERVICE_CONFIG_URLACL_QUERY *PHTTP_SERVICE_CONFIG_URLACL_QUERY;

// Cache Paramemers

typedef
[
	helpstring("For manipulating global cache parameters. The parameters that can be changed or queued are per - uri cache size and cached range chunk size.")
]
enum _HTTP_SERVICE_CONFIG_CACHE_KEY
{
	MaxCacheResponseSize = 0,
	CacheRangeChunkSize
} HTTP_SERVICE_CONFIG_CACHE_KEY;
typedef [public] HTTP_SERVICE_CONFIG_CACHE_KEY *PHTTP_SERVICE_CONFIG_CACHE_KEY;

typedef ULONG HTTP_SERVICE_CONFIG_CACHE_PARAM, *PHTTP_SERVICE_CONFIG_CACHE_PARAM;

typedef
[
	helpstring("To set a cache parameter value use the set structure. To query use the key directly.When you query a parameter value the output buffer must be exactly the sizeof param."),
	uuid(7D7F269D-CE99-4EE1-979D-387F6F2147BE)
]
struct HTTP_SERVICE_CONFIG_CACHE_SET
{
	HTTP_SERVICE_CONFIG_CACHE_KEY       KeyDesc;
	HTTP_SERVICE_CONFIG_CACHE_PARAM     ParamDesc;
} HTTP_SERVICE_CONFIG_CACHE_SET;
	
typedef [public] HTTP_SERVICE_CONFIG_CACHE_SET *PHTTP_SERVICE_CONFIG_CACHE_SET;

[
	uuid(06475580-47CF-4641-9EB7-96D83F2D2E96),
	helpstring("Windows HTTP Server API"),
	dllname("HttpApi.dll")
]
module HttpApi
{
		//const VARIANT varEmpty;// = { VT_EMPTY, 0 };

		// Flags for HttpInitialize() and HttpTerminate().
		//
		// Notes -
		// 1. These flags can be used in combination.
		// 2. HttpTerminate() must be called for each call to HttpInitialize() made
		//    with each flag set when invoking HttpInitialize.  For example, one
		//    could make two calls to HttpInitialize() setting HTTP_INITIALIZE_SERVER
		//    the first time and HTTP_INITIALIZE_CONFIG the second time.  One call
		//    to HttpTerminate() with both flags set suffices to clean up both
		//    calls to HttpInitialize().
		//

		// Flags for HttpInitialize() and HttpTerminate().
		[helpstring("Initializes the HTTP API layer and driver for applications using server APIs.")]
	const ULONG HTTP_INITIALIZE_SERVER = 0x00000001;
	[helpstring("Initializes the HTTP API layer and driver for applications using HTTP configuration APIs.")]
	const ULONG	HTTP_INITIALIZE_CONFIG = 0x00000002;
	//[helpstring("No longer used")]
	//const ULONG HTTP_DEMAND_CBT = 0x00000004;

	// HttpSetRequestQueueProperty - HttpServerQueueLengthProperty?
	const int HTTP_MAX_SERVER_QUEUE_LENGTH = 0x7FFFFFFF;
	const int HTTP_MIN_SERVER_QUEUE_LENGTH = 1;

	[helpstring("Bandwidth throttling limit can not be set lower than the following number. The value is in bytes/sec.")]
	const ULONG HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE = 1024;

	[helpstring("Distinguished value for bandwidth, connection limits and logging rollover size indicating 'no limit'.")]
	const ULONG HTTP_LIMIT_INFINITE = ((ULONG)-1);

	// Consts used for setting server side authentication property.

	const DWORD HTTP_AUTH_ENABLE_BASIC = (0x00000001);
	const DWORD HTTP_AUTH_ENABLE_DIGEST = (0x00000002);
	const DWORD HTTP_AUTH_ENABLE_NTLM = (0x00000004);
	const DWORD HTTP_AUTH_ENABLE_NEGOTIATE = (0x00000008);
	const DWORD HTTP_AUTH_ENABLE_KERBEROS = (0x00000010);
	const DWORD HTTP_AUTH_ENABLE_ALL = 0x0000001F;	// (HTTP_AUTH_ENABLE_BASIC | HTTP_AUTH_ENABLE_DIGEST | HTTP_AUTH_ENABLE_NTLM | HTTP_AUTH_ENABLE_NEGOTIATE | HTTP_AUTH_ENABLE_KERBEROS)


	const UCHAR HTTP_AUTH_EX_FLAG_ENABLE_KERBEROS_CREDENTIAL_CACHING = (0x01);
	const UCHAR HTTP_AUTH_EX_FLAG_CAPTURE_CREDENTIAL = (0x02);

	// Channel binding token verification flags.

	const DWORD HTTP_CHANNEL_BIND_PROXY = 0x1;
	const DWORD HTTP_CHANNEL_BIND_PROXY_COHOSTING = 0x20;

	// Service bind verification flags
	const DWORD HTTP_CHANNEL_BIND_NO_SERVICE_NAME_CHECK = 0x2;
	const DWORD HTTP_CHANNEL_BIND_DOTLESS_SERVICE = 0x4;

	// Flags triggering channel bind parameters retrieval
	const DWORD HTTP_CHANNEL_BIND_SECURE_CHANNEL_TOKEN = 0x8;
	const DWORD HTTP_CHANNEL_BIND_CLIENT_SERVICE = 0x10;

	//
	// Consts used for setting logging property.
	//

	//
	// The known log fields recognized/supported by HTTPAPI. Following fields
	// are used for W3C logging. Subset of them are also used for error
	// logging.
	//

	const DWORD HTTP_LOG_FIELD_DATE = 0x00000001;
	const DWORD HTTP_LOG_FIELD_TIME = 0x00000002;
	const DWORD HTTP_LOG_FIELD_CLIENT_IP = 0x00000004;
	const DWORD HTTP_LOG_FIELD_USER_NAME = 0x00000008;
	const DWORD HTTP_LOG_FIELD_SITE_NAME = 0x00000010;
	const DWORD HTTP_LOG_FIELD_COMPUTER_NAME = 0x00000020;
	const DWORD HTTP_LOG_FIELD_SERVER_IP = 0x00000040;
	const DWORD HTTP_LOG_FIELD_METHOD = 0x00000080;
	const DWORD HTTP_LOG_FIELD_URI_STEM = 0x00000100;
	const DWORD HTTP_LOG_FIELD_URI_QUERY = 0x00000200;
	const DWORD HTTP_LOG_FIELD_STATUS = 0x00000400;
	const DWORD HTTP_LOG_FIELD_WIN32_STATUS = 0x00000800;
	const DWORD HTTP_LOG_FIELD_BYTES_SENT = 0x00001000;
	const DWORD HTTP_LOG_FIELD_BYTES_RECV = 0x00002000;
	const DWORD HTTP_LOG_FIELD_TIME_TAKEN = 0x00004000;
	const DWORD HTTP_LOG_FIELD_SERVER_PORT = 0x00008000;
	const DWORD HTTP_LOG_FIELD_USER_AGENT = 0x00010000;
	const DWORD HTTP_LOG_FIELD_COOKIE = 0x00020000;
	const DWORD HTTP_LOG_FIELD_REFERER = 0x00040000;
	const DWORD HTTP_LOG_FIELD_VERSION = 0x00080000;
	const DWORD HTTP_LOG_FIELD_HOST = 0x00100000;
	const DWORD HTTP_LOG_FIELD_SUB_STATUS = 0x00200000;
	const DWORD HTTP_LOG_FIELD_STREAM_ID = 0x08000000;

	//Fields that are used only for error logging.
	const DWORD HTTP_LOG_FIELD_CLIENT_PORT = 0x00400000;
	const DWORD HTTP_LOG_FIELD_URI = 0x00800000;
	const DWORD HTTP_LOG_FIELD_SITE_ID = 0x01000000;
	const DWORD HTTP_LOG_FIELD_REASON = 0x02000000;
	const DWORD HTTP_LOG_FIELD_QUEUE_NAME = 0x04000000;


	[helpstring("Log file rollover size can not be set lower than the this limit. The value is in bytes.")]
	const ULONG HTTP_MIN_ALLOWED_LOG_FILE_ROLLOVER_SIZE = ((ULONG)(1 * 1024 * 1024));

	// Logging option flags. When used in the logging configuration alterssome default logging behaviour.
	[helpstring("This flag is used to change the log file rollover to happen by local time based.By default log file rollovers happen by GMT time.")]
	const DWORD HTTP_LOGGING_FLAG_LOCAL_TIME_ROLLOVER = (0x00000001);
	[helpstring("HTTP_LOGGING_FLAG_USE_UTF8_CONVERSION - When set the unicode fields will be converted to UTF8 multibytes when writting to the log files. When this flag is not present, the local code page conversion happens.")]
	const DWORD HTTP_LOGGING_FLAG_USE_UTF8_CONVERSION = (0x00000002);
	[helpstring("Selectively log only errors. Mutually exclusive with HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY.")]
	const DWORD HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY = (0x00000004);
	[helpstring("Selectively log only success. Mutually exclusive with HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY.")]
	const DWORD HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY = (0x00000008);

	// Consts for request queue manipulation.
	// These flags are used with HttpCreateRequestQueue() API.
	[helpstring("To open an existing request queue.The request queue name must be supplied.")]
	const DWORD HTTP_CREATE_REQUEST_QUEUE_FLAG_OPEN_EXISTING = (0x00000001);
	[helpstring("HTTP_CREATE_REQUEST_QUEUE_FLAG_CONTROLLER - Creates the request queue and marks that the caller process is not willing to do send / receive(HTTP I / O) on the handle directly.")]
	const DWORD HTTP_CREATE_REQUEST_QUEUE_FLAG_CONTROLLER = (0x00000002);


	[helpstring("Specifies that the caller would like any available entity body to be copied along with the protocol headers.")]
	const DWORD HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY = 0x00000001;
	[helpstring("Specifies that the caller would like all of the entity bodies to be copied along with the protocol headers.")]
	const DWORD HTTP_RECEIVE_REQUEST_FLAG_FLUSH_BODY = 0x00000002;


	// Flags for HttpReceiveRequestEntityBody().
	[helpstring("Specifies that the caller would like the buffer to get filled up with entity bodies unless there are no more entity bodies to be copied.")]
	const DWORD HTTP_RECEIVE_REQUEST_ENTITY_BODY_FLAG_FILL_BUFFER = 0x00000001;


	// Flags for HttpSendHttpResponse() and HttpSendResponseEntityBody()
	[helpstring("Specifies that the network connection should be disconnected immediately after sending the response, overriding the HTTP protocol's persistent connection features, such as 'Connection: keep-alive'.")]
	const DWORD HTTP_SEND_RESPONSE_FLAG_DISCONNECT = 0x00000001;
	[helpstring("Specifies that additional entity body data will be sent by the caller.")]
	const DWORD HTTP_SEND_RESPONSE_FLAG_MORE_DATA = 0x00000002;
	[helpstring("Specifies that a caller wants the response to complete as soon as possible at the cost of buffering partial or the entire response.")]
	const DWORD HTTP_SEND_RESPONSE_FLAG_BUFFER_DATA = 0x00000004;
	[helpstring("Specifies that a caller wants to enable the TCP nagling algorithm for this particular send.")]
	const DWORD HTTP_SEND_RESPONSE_FLAG_ENABLE_NAGLING = 0x00000008;
	[helpstring("Specifies that for a range request a full response content is passed and a caller wants HTTP API to process ranges properly.")]
	const DWORD HTTP_SEND_RESPONSE_FLAG_PROCESS_RANGES = 0x00000020;
	[helpstring("Specifies that the request/response is not HTTP compliant and all subsequent bytes should be treated as entity-body.")]
	const DWORD HTTP_SEND_RESPONSE_FLAG_OPAQUE = 0x00000040;

	// Flags for HttpFlushResponseCache().
	[helpstring("Flushes the specified URL and all hierarchally-related sub-URLs from the response or fragment cache.")]
	const DWORD HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE = 0x00000001;

	[helpstring("When set as HTTP_BYTE_RANGE.Length (which, note is 64-bit unsigned int), specifies that the range extends from the starting offset to the end of the file or data block.")]
	const LONG HTTP_BYTE_RANGE_TO_EOF = -1;

	[helpstring("Use with HttpRemoveUrlFromUrlGroup to remove all URLs from the group.")]
	const DWORD HTTP_URL_FLAG_REMOVE_ALL = 0x00000001;

	[helpstring("Flag to retrieve secure channel binding with HttpReceiveClientCertificate")]
	const int HTTP_RECEIVE_SECURE_CHANNEL_TOKEN = 0x1;

	[helpstring("Used for HTTP_REQUEST_AUTH_INFO.Flags; specifies that the provided token is for NTLM and is based on a cached credential of a Keep Alive (KA) connection.")]
	const DWORD HTTP_REQUEST_AUTH_FLAG_TOKEN_FOR_CACHED_CRED = (0x00000001);

	// Values for HTTP_REQUEST::Flags.Zero or more of these may be ORed together.
	[helpstring("There is more entity body to be read for this request. Otherwise, there is no entity body or all of the entity body was copied into pEntityChunks.")]
	const DWORD HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS = 0x00000001;
	[helpstring("This flag indicates that the request has been routed based on host plus ip or ip binding. This is a hint for the application to include the local ip while flushing kernel cache entries build for thisrequest if any.")]
	const DWORD HTTP_REQUEST_FLAG_IP_ROUTED = 0x00000002;
	[helpstring("Indicates the request was received over HTTP/2.")]
	const DWORD HTTP_REQUEST_FLAG_HTTP2 = 0x00000004;

	// Values for HTTP_RESPONSE::Flags."
	[helpstring("Set this flag if encodings other than identity form are available for this resource.This flag is ignored if application has not asked for response to be cached.")]
	const DWORD HTTP_RESPONSE_FLAG_MULTIPLE_ENCODINGS_AVAILABLE = 0x00000001;

	[helpstring("Used with HTTP_MULTIPLE_KNOWN_HEADERS; specifies that the order of authentication schemes should be preserved on the challenge response.")]
	const DWORD HTTP_RESPONSE_INFO_FLAGS_PRESERVE_ORDER = 0x00000001;

	// HTTP_SERVICE_CONFIG_SSL_PARAM.DefaultFlags
	[helpstring("Client certificates are mapped where possible to corresponding operating - system user accounts based on the certificate mapping rules stored in Active Directory.")]
	const DWORD HTTP_SERVICE_CONFIG_SSL_FLAG_USE_DS_MAPPER = 0x00000001;
	[helpstring("Enables a client certificate to be cached locally for subsequent use.")]
	const DWORD HTTP_SERVICE_CONFIG_SSL_FLAG_NEGOTIATE_CLIENT_CERT = 0x00000002;
	[helpstring("Prevents SSL requests from being passed to low-level ISAPI filters.")]
	const DWORD HTTP_SERVICE_CONFIG_SSL_FLAG_NO_RAW_FILTER = 0x00000004;
	[helpstring("Not currently documented?")]
	const DWORD HTTP_SERVICE_CONFIG_SSL_FLAG_REJECT = 0x00000008;

	[
		entry("HttpInitialize"),
		helpstring("The HttpInitialize function initializes the HTTP Server API driver, starts it, if it has not already been started, and allocates data structures for the calling application to support response-queue creation and other operations.")
	]
	ULONG
	WINAPI
	HttpInitialize(
		//[helpstring("HTTP version. This parameter is an HTTPAPI_VERSION structure. For the current version, declare an instance of the structure and set it to the pre-defined value HTTPAPI_VERSION_1 before passing it to HttpInitialize.")]
		IN HTTPAPI_VERSION Version,
		//[helpstring("Initialization options.")]
		IN ULONG Flags,
		_Reserved_ IN OUT PVOID pReserved
	);

	// NOTE: MUST be called after final API call returns.

	[
		entry("HttpTerminate"),
		helpstring("Cleans up resources used by the HTTP Server API to process calls by an application. An application should call HttpTerminate once for every time it called HttpInitialize, with matching flag settings.")
	]
	ULONG
	WINAPI
	HttpTerminate(
		//[helpstring("Termination options.")]
		IN ULONG Flags,
		_Reserved_ IN OUT PVOID pReserved
	);

	// Extended Request Queue manipulation APIs.

	[
		entry("HttpCreateRequestQueue"),
		helpstring("Creates a new request queue or opens an existing request queue.")
	]
	ULONG
	WINAPI
	HttpCreateRequestQueue(
		//[helpstring("Indicates the required request queue version. For version 2.0, use predefined value HTTPAPI_VERSION_2 to initialize the structure argument.")]
		IN HTTPAPI_VERSION Version,
		//[helpstring("The name of the request queue. The length, in bytes, cannot exceed MAX_PATH.")]
		IN PCWSTR Name OPTIONAL,
		//[helpstring("A pointer to the SECURITY_ATTRIBUTES structure that contains the access permissions for the request queue.")]
		IN PSECURITY_ATTRIBUTES SecurityAttributes OPTIONAL,
		//[helpstring("The flags parameter defines the scope of the request queue.")]
		IN ULONG Flags OPTIONAL,
		//[helpstring("A pointer to a variable that receives a handle to the request queue.")]
		OUT PHANDLE RequestQueueHandle
	);


	[
		entry("HttpCloseRequestQueue"),
		helpstring("Close a request queue when it is no longer required.")
	]
	ULONG
	WINAPI
	HttpCloseRequestQueue(
		//[helpstring("The handle to the request queue that is closed.")]
		IN HANDLE RequestQueueHandle
	);

	[
		entry("HttpSetRequestQueueProperty"),
		helpstring("Set a new property or modifies an existing property on the request queue identified by the specified handle.")
	]
	ULONG
	WINAPI
	HttpSetRequestQueueProperty(
		//[helpstring("The handle to the request queue on which the property is set.")]
		IN HANDLE RequestQueueHandle,
		//[helpstring("A member of the HTTP_SERVER_PROPERTY enumeration describing the property type that is set.")]
		IN HTTP_SERVER_PROPERTY Property,
			//[helpstring("A pointer to the buffer that contains the property information.")]
		_In_reads_bytes_(PropertyInformationLength) PVOID PropertyInformation,
			//[helpstring("The length, in bytes, of the buffer pointed to by the pPropertyInformation parameter.")]
		IN ULONG PropertyInformationLength,
		_Reserved_ IN ULONG Reserved1,
		_Reserved_ IN PVOID Reserved2
	);

	[
		entry("HttpQueryRequestQueueProperty"),
		helpstring("Query a property of the request queue identified by the specified handle")
	]
	ULONG
	WINAPI
	HttpQueryRequestQueueProperty(
		//[helpstring("The handle to the request queue for which the property setting is to be returned.")]
		IN HANDLE RequestQueueProperty,
		//[helpstring("A member of the HTTP_SERVER_PROPERTY enumeration that describes the property to query.")]
		IN HTTP_SERVER_PROPERTY Property,
		//[helpstring("A pointer to the buffer that receives the property information.")]
		_Out_writes_bytes_to_opt_(PropertyInformationLength, *ReturnLength) PVOID PropertyInformation,
		//[helpstring("The length, in bytes, of the buffer pointed to by the pPropertyInformation parameter.")]
		IN ULONG PropertyInformationLength,
		_Reserved_ IN ULONG Reserved1,
		//[helpstring("The number, in bytes, returned in the pPropertyInformation buffer if not NULL, else the size of the buffer required.")]
		_Out_opt_ PULONG ReturnLength OPTIONAL,
		_Reserved_ IN PVOID Reserved2
	);

	[
		entry("HttpShutdownRequestQueue"),
		helpstring("Stop queuing requests for the specified request queue process.")
	]
	ULONG
	WINAPI
	HttpShutdownRequestQueue(
		//[helpstring("The handle to the request queue that is to be shut down")]
		IN HANDLE RequestQueueHandle
	);

	// SSL APIs.

	[
		entry("HttpReceiveClientCertificate")
	]
	ULONG
	WINAPI
	HttpReceiveClientCertificate(
		IN HANDLE RequestQueueHandle,
		IN HTTP_CONNECTION_ID ConnectionId,
		IN ULONG Flags,
		_Out_writes_bytes_to_(SslClientCertInfoSize, *BytesReceived) PHTTP_SSL_CLIENT_CERT_INFO SslClientCertInfo,
		IN ULONG SslClientCertInfoSize,
		_Out_opt_ PULONG BytesReceived,
		IN LPOVERLAPPED Overlapped OPTIONAL
	);

	// Server Session APIs.

	[
		entry("HttpCreateServerSession"),
		helpstring("Create a server session for the specified version.")
	]
	ULONG
	WINAPI
	HttpCreateServerSession(
		//[helpstring("Indicates the requested version for the server session.")]
		IN HTTPAPI_VERSION Version,
		//[helpstring("A pointer to the variable that receives the ID of the server session.")]
		OUT PHTTP_SERVER_SESSION_ID ServerSessionId,
		_Reserved_ IN ULONG Reserved
	);

	[
		entry("HttpCloseServerSession"),
		helpstring("Deletes the server session identified by the server session ID. All remaining URL Groups associated with the server session will also be closed.")
	]
	ULONG
	WINAPI
	HttpCloseServerSession(
		//[helpstring("The ID of the server session that is to be closed.")]
		IN HTTP_SERVER_SESSION_ID ServerSessionId
	);

	[
		entry("HttpQueryServerSessionProperty"),
		helpstring("Queries a server property on the specified server session.")
	]
	_Success_(return == NO_ERROR)
	ULONG
	WINAPI
	HttpQueryServerSessionProperty(
		//[helpstring("The server session for which the property is to be queried.")]
		IN HTTP_SERVER_SESSION_ID ServerSessionId,
		//[helpstring("A member of the HTTP_SERVER_PROPERTY enumeration that identifies the property to be queried.")]
		IN HTTP_SERVER_PROPERTY Property,
		//[helpstring("A pointer to the buffer that receives the property data.")]
		_Out_writes_bytes_to_opt_(PropertyInformationLength, *ReturnLength) PVOID PropertyInformation,
		//[helpstring("The length, in bytes, of the buffer pointed to by the PropertyInformation parameter.")]
		IN ULONG PropertyInformationLength,
		//[helpstring("The number of bytes returned in the pPropertyInformation buffer.")]
		_Out_opt_ PULONG ReturnLength
	);

	[
		entry("HttpSetServerSessionProperty"),
		helpstring("Sets a new server session property or modifies an existing property on the specified server session.")
	]
		ULONG
		WINAPI
		HttpSetServerSessionProperty(
			//[helpstring("The server session for which the property is to be set.")]
			IN HTTP_SERVER_SESSION_ID ServerSessionId,
			//[helpstring("A member of the HTTP_SERVER_PROPERTY enumeration that identifies the property to be set.")]
		IN HTTP_SERVER_PROPERTY Property,
			//[helpstring("A pointer to the buffer that contains the property data.")]
		_In_reads_bytes_(PropertyInformationLength) PVOID PropertyInformation,
			//[helpstring("The length, in bytes, of PropertyInformation buffer.")]
		IN ULONG PropertyInformationLength
	);


	// Url Group APIs

	[
		entry("HttpCreateUrlGroup"),
		helpstring("Creates a URL Group under the specified server session.")
	]
	ULONG
	WINAPI
	HttpCreateUrlGroup(
		//[helpstring("The identifier of the server session under which the URL Group is created.")]
		IN HTTP_SERVER_SESSION_ID ServerSessionId,
		//[helpstring("A pointer to the variable that receives the ID of the URL Group.")]
		OUT PHTTP_URL_GROUP_ID pUrlGroupId,
		_Reserved_ IN ULONG Reserved
	);

	[
		entry("HttpCloseUrlGroup"),
		helpstring("Closes the URL Group identified by the URL Group ID. This call also removes all of the URLs that are associated with the URL Group")
	]
	ULONG
	WINAPI
	HttpCloseUrlGroup(
		//[helpstring("The ID of the URL Group that is to be deleted.")]
		IN HTTP_URL_GROUP_ID UrlGroupId
	);

	[
		entry("HttpAddUrlToUrlGroup"),
		helpstring("Adds the specified URL to the URL Group identified by the URL Group ID.")
	]
	ULONG
	WINAPI
	HttpAddUrlToUrlGroup(
		//[helpstring("The group ID for the URL group to which requests for the specified URL are routed. The URL group is created by the HttpCreateUrlGroup function.")]
		IN HTTP_URL_GROUP_ID UrlGroupId,
		//[helpstring("A pointer to a Unicode string that contains a properly formed UrlPrefix String that identifies the URL to be registered.")]
		IN PCWSTR pFullyQualifiedUrl,
		//[helpstring("The context that is associated with the URL registered in this call. The URL context is returned in the HTTP_REQUEST structure with every request received on the URL specified in the pFullyQualifiedUrl parameter.")]
		IN HTTP_URL_CONTEXT UrlContext OPTIONAL,
		_Reserved_ IN ULONG Reserved
	);

	[
		entry("HttpRemoveUrlFromUrlGroup"),
		helpstring("The HttpRemoveUrlFromUrlGroup function removes the specified URL from the group identified by the URL Group ID. This function removes one, or all, of the URLs from the group. ")
	]
	ULONG
	WINAPI
	HttpRemoveUrlFromUrlGroup(
		//[helpstring("The ID of the URL group from which the URL specified in pFullyQualifiedUrl is removed.")]
		IN HTTP_URL_GROUP_ID UrlGroupId,
		//[helpstring("A pointer to a Unicode string that contains a properly formed UrlPrefix String that identifies the URL to be removed. NULL if removing all URLs from the group with flag HTTP_URL_FLAG_REMOVE_ALL.")]
		IN PCWSTR pFullyQualifiedUrl,
		//[helpstring("The URL flags qualifying the URL that is removed.")]
		IN ULONG Flags
	);

	[
		entry("HttpSetUrlGroupProperty"),
		helpstring("Sets a new property or modifies an existing property on the specified URL Group.")
	]
	ULONG
	WINAPI
	HttpSetUrlGroupProperty(
		//[helpstring("The ID of the URL Group for which the property is to be set.")]
		IN HTTP_URL_GROUP_ID UrlGroupId,
		//[helpstring("A member of the HTTP_SERVER_PROPERTY enumeration that identifies the property that is to be modified or set.")]
		IN HTTP_SERVER_PROPERTY Property,
		//[helpstring("A pointer to the buffer that contains the property information.")]
		_In_reads_bytes_(PropertyInformationLength) PVOID PropertyInformation,
		//[helpstring("The size in bytes of the property data in the PropertyInformation buffer.")]
		IN ULONG PropertyInformationLength
	);

	[
		entry("HttpQueryUrlGroupProperty"),
		helpstring("Query a property on the specified URL Group.")
	]
	_Success_(return == NO_ERROR)
	ULONG
	WINAPI
	HttpQueryUrlGroupProperty(
		//[helpstring("The ID of the URL Group for which the property is to be queried.")]
		IN HTTP_URL_GROUP_ID UrlGroupId,
		//[helpstring("A member of the HTTP_SERVER_PROPERTY enumeration that identifies the property that is to be queried.")]
		IN HTTP_SERVER_PROPERTY Property,
		//[helpstring("A pointer to the buffer that receives the property information.")]
		_Out_writes_bytes_to_opt_(PropertyInformationLength, *ReturnLength) PVOID PropertyInformation,
		//[helpstring("The size, in bytes, of the buffer pointed to by the PropertyInformation parameter.")]
		IN ULONG PropertyInformationLength,
		//[helpstring("The size, in bytes, of the property data returned in the PropertyInformation buffer.")]
		_Out_opt_ PULONG ReturnLength
	);


	[
		entry("HttpPrepareUrl"),
		helpstring("Parses, analyzes, and normalizes a non-normalized Unicode or punycode URL so it is safe and valid to use in other HTTP functions (Win8+).")
	]
	ULONG
	WINAPI
	HttpPrepareUrl(
		_Reserved_ PVOID Reserved,
		_Reserved_ ULONG Flags,
		//[helpstring("A pointer to a string that represents the non-normalized Unicode or punycode URL to prepare.")]
		_In_ PCWSTR Url,
		//[helpstring("On successful output, a pointer to a string that represents the normalized URL. Free with HeapFree.")]
		_Outptr_ PWSTR *PreparedUrl
	);

	// HTTP Server I/O APIs.

	[
		entry("HttpReceiveHttpRequest"),
		helpstring("Retrieve the next available HTTP request from the specified request queue either synchronously or asynchronously.")
	]
	ULONG
	WINAPI
	HttpReceiveHttpRequest(
		//[helpstring("Handle of the request queue from which to retrieve the next available request.")]
		IN HANDLE RequestQueueHandle,
		//[helpstring("On the first call this should be HTTP_NULL_ID. Then, on any subsequent calls required retrieve the remainder of the request, set to the RequestId value returned in the HTTP_REQUEST structure .")]
		IN HTTP_REQUEST_ID RequestId,
		//[helpstring("HTTP_RECEIVE_REQUEST_* flags")]
		IN ULONG Flags,
		//[helpstring("A pointer to a buffer into which the function copies an HTTP_REQUEST structure and entity body for the HTTP request. ")]
		_Out_writes_bytes_to_(RequestBufferLength, *BytesReturned) PHTTP_REQUEST RequestBuffer,
		//[helpstring("Size, in bytes, of the pRequestBuffer buffer.")]
		IN ULONG RequestBufferLength,
		//[helpstring("Optional. A pointer to a variable that receives the size, in bytes, of the entity body, or of the remaining part of the entity body.")]
		_Out_opt_ PULONG BytesReturned,
		//[helpstring("For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure; for synchronous calls, set it to NULL.")]
		IN LPOVERLAPPED Overlapped OPTIONAL
	);

	[
		entry("HttpReceiveRequestEntityBody")
	]
	ULONG
	WINAPI
	HttpReceiveRequestEntityBody(
		//[helpstring("Handle of the request queue from which to retrieve the entity body data.")]
		IN HANDLE RequestQueueHandle,
		//[helpstring("The identifier of the HTTP request that contains the retrieved entity body. This value is returned in the RequestId member of the HTTP_REQUEST structure by a call to the HttpReceiveHttpRequest function. This value cannot be HTTP_NULL_ID.")]
		IN HTTP_REQUEST_ID RequestId,
		//[helpstring("HTTP_RECEIVE_REQUEST_ENTITY_BODY_FLAG_* flags")]
		IN ULONG Flags,
		//[helpstring("A pointer to a buffer that receives entity-body data.")]
		_Out_writes_bytes_to_(EntityBufferLength, *BytesReturned) PVOID EntityBuffer,
		//[helpstring("The size, in bytes, of the buffer pointed to by the pBuffer parameter.")]
		IN ULONG EntityBufferLength,
		//[helpstring("Optional. A pointer to a variables that receives the size, in bytes, of the entity body data returned in the pBuffer buffer.")]
		_Out_opt_ PULONG BytesReturned,
		//[helpstring("For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure; for synchronous calls, set it to NULL.")]
		IN LPOVERLAPPED Overlapped OPTIONAL
	);

	[
		helpstring("Sends an HTTP response to the specified HTTP request."),
		entry("HttpSendHttpResponse")
	]
	ULONG
	WINAPI
	HttpSendHttpResponse(
		//[helpstring("A handle to the request queue from which the specified request was retrieved. A request queue is created and its handle returned by a call to the HttpCreateRequestQueue function.")]
		IN HANDLE RequestQueueHandle,
		//[helpstring("An identifier of the HTTP request to which this response corresponds. This value is returned in the RequestId member of the HTTP_REQUEST structure by a call to the HttpReceiveHttpRequest function. This value cannot be HTTP_NULL_ID.")]
		IN HTTP_REQUEST_ID RequestId,
		//[helpstring("HTTP_SEND_RESPONSE_XXX flags")]
		IN ULONG Flags,
		//[helpstring("A pointer to an HTTP_RESPONSE structure that defines the HTTP response.")]
		IN PHTTP_RESPONSE HttpResponse,
		//[helpstring("A pointer to the HTTP_CACHE_POLICY structure used to cache the response.")]
		IN PHTTP_CACHE_POLICY CachePolicy OPTIONAL,
		//[helpstring("Optional. A pointer to a variable that receives the number, in bytes, sent if the function operates synchronously.")]
		OUT PULONG BytesSent OPTIONAL,
		//[helpstring("This parameter is reserved and must be NULL.")]
		_Reserved_ PVOID Reserved2,
		//[helpstring("This parameter is reserved and must be zero.")]
		_Reserved_ ULONG Reserved3,
		//[helpstring("For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure; for synchronous calls, set to NULL.")]
		IN LPOVERLAPPED Overlapped OPTIONAL,
		//[helpstring("A pointer to the HTTP_LOG_DATA structure used to log the response. Pass a pointer to the HTTP_LOG_FIELDS_DATA structure and cast it to PHTTP_LOG_DATA. Not supported prior to Vista/2k8")]
		IN PHTTP_LOG_DATA LogData OPTIONAL
	);

	[
		entry("HttpSendResponseEntityBody"),
		helpstring("Sends entity-body data associated with an HTTP response.")
	]
	ULONG
	WINAPI
	HttpSendResponseEntityBody(
		//[helpstring("A handle to the request queue from which the specified request was retrieved. A request queue is created and its handle returned by a call to the HttpCreateRequestQueue function.")]
		IN HANDLE RequestQueueHandle,
		//[helpstring("An identifier of the HTTP request to which this response corresponds. This value is returned in the RequestId member of the HTTP_REQUEST structure by a call to the HttpReceiveHttpRequest function. This value cannot be HTTP_NULL_ID.")]
		IN HTTP_REQUEST_ID RequestId,
		//[helpstring("HTTP_SEND_RESPONSE_XXX flags")]
		IN ULONG Flags,
		//[helpstring("A number of structures in the array pointed to by pEntityChunks.This count cannot exceed 9999.")]
		IN USHORT EntityChunkCount OPTIONAL,
		//[helpstring("A pointer to an array of HTTP_DATA_CHUNK structures to be sent as entity-body data.")]
		_In_reads_opt_(EntityChunkCount) PHTTP_DATA_CHUNK EntityChunks,
		//[helpstring("Optional. A pointer to a variable that receives the number, in bytes, sent if the function operates synchronously.")]
		OUT PULONG BytesSent OPTIONAL,
		//[helpstring("This parameter is reserved and must be NULL.")]
		_Reserved_ PVOID Reserved1 OPTIONAL,
		//[helpstring("This parameter is reserved and must be zero.")]
		_Reserved_ ULONG Reserved2 OPTIONAL,
		//[helpstring("For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure; for synchronous calls, set to NULL.")]
		IN LPOVERLAPPED Overlapped OPTIONAL,
		//[helpstring("A pointer to the HTTP_LOG_DATA structure used to log the response. Pass a pointer to the HTTP_LOG_FIELDS_DATA structure and cast it to PHTTP_LOG_DATA. Not supported prior to Vista/2k8")]
		IN PHTTP_LOG_DATA LogData OPTIONAL
	);

	[
		entry("HttpDeclarePush"),
		helpstring("Declares a resource-to-subresource relationship to use for an HTTP server push. HTTP.sys then performs an HTTP 2.0 server push for the given resource, if the underlying protocol, connection, client, and policies allow the push operation.")
	]
	ULONG
	WINAPI
	HttpDeclarePush(
		//[helpstring("The handle to an HTTP.sys request queue that the HttpCreateRequestQueue function returned.")]
		_In_ HANDLE RequestQueueHandle,
		//[helpstring("The opaque identifier of the request that is declaring the push operation. The request must be from the specified queue handle. ")]
		_In_ HTTP_REQUEST_ID RequestId,
		//[helpstring("The HTTP verb to use for the push operation. The HTTP.sys push operation only supports HttpVerbGET and HttpVerbHEAD.")]
		_In_ HTTP_VERB Verb,
		//[helpstring("The path portion of the URL for the resource being pushed.")]
		_In_ PCWSTR Path,
		//[helpstring("The query portion of the URL for the resource being pushed. This string should not include the leading question mark (?).")]
		_In_opt_ LPCSTR Query,
		//[helpstring("The request headers for the push operation.")]
		_In_opt_ PHTTP_REQUEST_HEADERS Headers
	);

	[
		entry("HttpWaitForDisconnect"),
		helpstring("Notifies the application when the connection to an HTTP client is broken for any reason.")
	]
	ULONG
	WINAPI
	HttpWaitForDisconnect(
		//[helpstring("A handle to the request queue that handles requests from the specified connection.")]
		IN HANDLE RequestQueueHandle,
		//[helpstring("Identifier for the connection to the client computer. This value is returned in the ConnectionID member of the HTTP_REQUEST structure by a call to the HttpReceiveHttpRequest function.")]
		IN HTTP_CONNECTION_ID ConnectionId,
		//[helpstring("For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure; for synchronous calls, set it to NULL.")]
		IN LPOVERLAPPED Overlapped OPTIONAL
	);

	[
		entry("HttpWaitForDisconnectEx"),
		helpstring("This function is an extension to HttpWaitForDisconnect.")
	]
	ULONG
	WINAPI
	HttpWaitForDisconnectEx(
		//[helpstring("A handle to the request queue that handles requests from the specified connection.")]
		IN HANDLE RequestQueueHandle,
		//[helpstring("Identifier for the connection to the client computer. This value is returned in the ConnectionID member of the HTTP_REQUEST structure by a call to the HttpReceiveHttpRequest function.")]
		IN HTTP_CONNECTION_ID ConnectionId,
		_Reserved_ IN ULONG Reserved OPTIONAL,
		//[helpstring("For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure; for synchronous calls, set it to NULL.")]
		IN LPOVERLAPPED Overlapped OPTIONAL
	);

	[
		entry("HttpCancelHttpRequest"),
		helpstring("Cancels a specified reqest.")
	]
	ULONG
	WINAPI
	HttpCancelHttpRequest(
		//[helpstring("A handle to the request queue from which the request came.")]
		IN HANDLE RequestQueueHandle,
		//[helpstring("The ID of the request to be canceled.")]
		IN HTTP_REQUEST_ID RequestId,
		//[helpstring("For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure; for synchronous calls, set it to NULL.")]
		IN LPOVERLAPPED Overlapped OPTIONAL
	);


	[
		entry("HttpWaitForDemandStart"),
		helpstring("Wait for the arrival of a new request that can be served by a new request queue process.")
	]
	ULONG
	WINAPI
	HttpWaitForDemandStart(
		//[helpstring("A handle to the request queue on which demand start is registered.")]
		IN HANDLE RequestQueueHandle,
		//[helpstring("For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure; for synchronous calls, set it to NULL.")]
		IN LPOVERLAPPED Overlapped OPTIONAL
	);



	// Cache manipulation APIs.

	[
		entry("HttpFlushResponseCache"),
		helpstring("Remove from the HTTP Server API cache associated with a given request queue all response fragments that have a name whose site portion matches a specified UrlPrefix.")
	]
	ULONG
	WINAPI
	HttpFlushResponseCache(
		//[helpstring("Handle to the request queue with which this cache is associated.")]
		IN HANDLE RequestQueueHandle,
		//[helpstring("Pointer to a UrlPrefix string to match against the site portion of fragment names.")]
		IN PCWSTR UrlPrefix,
		//[helpstring("HTTP_FLUSH_RESPONSE_FLAG_* flags.")]
		IN ULONG Flags,
		//[helpstring("For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure, or for synchronous calls, set it to NULL. ")]
		IN LPOVERLAPPED Overlapped OPTIONAL
	);

	[
		entry("HttpAddFragmentToCache"),
		helpstring(" caches a data fragment with a specified name by which it can be retrieved, or updates data cached under a specified name. Such cached data fragments can be used repeatedly to construct dynamic responses without going to disk.")
	]
	ULONG
	WINAPI
	HttpAddFragmentToCache(
		//[helpstring("Handle to the request queue with which the specified response fragment is associated.")]
		IN HANDLE RequestQueueHandle,
		//[helpstring("Pointer to a UrlPrefix string that the application uses in subsequent calls to HttpSendHttpResponse to identify this cache entry.")]
		IN PCWSTR UrlPrefix,
		//[helpstring("Pointer to an HTTP_DATA_CHUNK structure that specifies an entity body data block to cache under the name pointed to by pUrlPrefix.")]
		IN PHTTP_DATA_CHUNK DataChunk,
		//[helpstring("Pointer to an HTTP_CACHE_POLICY structure that specifies how this data fragment should be cached.")]
		IN PHTTP_CACHE_POLICY CachePolicy,
		//[helpstring("For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure, or for synchronous calls, set it to NULL. ")]
		IN LPOVERLAPPED Overlapped OPTIONAL
	);

	[
		entry("HttpReadFragmentFromCache")
	]
	ULONG
	WINAPI
	HttpReadFragmentFromCache(
		//[helpstring("Handle to the request queue with which the specified response fragment is associated.")]
		IN HANDLE RequestQueueHandle,
		//[helpstring("Pointer to a UrlPrefix string that contains the name of the fragment to be retrieved. ")]
		IN PCWSTR UrlPrefix,
		//[helpstring("Optional pointer to an HTTP_BYTE_RANGE structure that indicates a starting offset in the specified fragment and byte-count to be returned. NULL if not used, in which case the entire fragment is returned.")]
		IN PHTTP_BYTE_RANGE ByteRange OPTIONAL,
		//[helpstring("Pointer to a buffer into which the function copies the requested fragment.")]
		_Out_writes_bytes_to_(BufferLength, *BytesRead) PVOID Buffer,
		//[helpstring("Size, in bytes, of the Buffer.")]
		IN ULONG BufferLength,
		//[helpstring("Optional pointer to a variable that receives the number of bytes to be written into the output buffer.")]
		_Out_opt_ PULONG BytesRead,
		//[helpstring("For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure, or for synchronous calls, set it to NULL. ")]
		IN LPOVERLAPPED Overlapped OPTIONAL
	);

	// Server configuration APIs

	[
		entry("HttpSetServiceConfiguration"),
		helpstring("creates and sets a configuration record for the HTTP Server API configuration store. The call fails if the specified record already exists.")
	]
	ULONG
	WINAPI
	HttpSetServiceConfiguration(
		_Reserved_ IN HANDLE ServiceHandle,
		//[helpstring("Type of configuration record to be set.")]
		IN HTTP_SERVICE_CONFIG_ID ConfigId,
		//[helpstring("A pointer to a buffer that contains the appropriate data to specify the type of record to be set.")]
		_In_reads_bytes_(ConfigInformationLength) IN PVOID pConfigInformation,
		//[helpstring("Size, in bytes, of the pConfigInformation buffer.")]
		IN ULONG ConfigInformationLength,
		_Reserved_ IN LPOVERLAPPED pOverlapped
	);

	[
		entry("HttpDeleteServiceConfiguration"),
		helpstring("Deletes specified data, such as IP addresses or SSL Certificates, from the HTTP Server API configuration store, one record at a time.")
	]
	ULONG
	WINAPI
	HttpDeleteServiceConfiguration(
		_Reserved_ IN HANDLE ServiceHandle,
		//[helpstring("Type of configuration record to be deleted.")]
		IN HTTP_SERVICE_CONFIG_ID ConfigId,
		//[helpstring("Pointer to a buffer that contains data required for the type of configuration specified in the ConfigId parameter.")]
		_In_reads_bytes_(ConfigInformationLength) IN PVOID pConfigInformation,
		//[helpstring("Size, in bytes, of the pConfigInformation buffer.")]
		IN ULONG ConfigInformationLength,
		_Reserved_ IN LPOVERLAPPED pOverlapped
	);

	[
		entry("HttpQueryServiceConfiguration"),
		helpstring("Retrieves one or more HTTP Server API configuration records.")
	]
	ULONG
	WINAPI
	HttpQueryServiceConfiguration(
		_Reserved_ IN HANDLE ServiceHandle,
		//[helpstring("The configuration record query type.")]
		IN HTTP_SERVICE_CONFIG_ID ConfigId,
		//[helpstring("A pointer to a structure whose contents further define the query.")]
		_In_reads_bytes_opt_(InputLength) IN PVOID pInput OPTIONAL,
		//[helpstring("Size, in bytes, of the ConfigInformation buffer.")]
		IN ULONG InputLength OPTIONAL,
		//[helpstring("A pointer to a buffer in which the query results are returned.")]
		_Out_writes_bytes_to_opt_(OutputLength, *pReturnLength) OUT PVOID pOutput OPTIONAL,
		//[helpstring("Size, in bytes, of the OutputConfigInfo buffer.")]
		IN ULONG OutputLength OPTIONAL,
		//[helpstring("A pointer to a variable that receives the number of bytes to be written in the output buffer.")]
		_Out_opt_ OUT PULONG pReturnLength OPTIONAL,
		_Reserved_ IN LPOVERLAPPED pOverlapped
	);
}
